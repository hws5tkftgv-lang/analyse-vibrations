<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Analyse de vibrations ‚Äî Poulies & courroie</title>

<style>
  :root{
    --bg:#0b1436;
    --panel:#101a40;
    --panel2:#0f1a44;
    --text:#eaf1ff;
    --muted:rgba(234,241,255,.78);
    --field:#0b0f18;
    --fieldText:#ffffff;
    --stroke:#8b8b8b;
    --blue:#00a2ff;
    --orange:#ff9800;
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html,body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial,system-ui,-apple-system,Segoe UI,sans-serif; }

  header{
    padding:14px 14px 12px;
    background:linear-gradient(180deg, #0f1a44, #0b1436);
    border-bottom:1px solid rgba(255,255,255,.12);
  }
  h1{ margin:0; font-size:18px; font-weight:700; letter-spacing:.2px; }

  .panel{
    padding:14px;
    background:var(--panel);
    display:grid;
    grid-template-columns: 1fr;
    gap:14px;
  }

  .row2{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  @media (max-width: 520px){
    .row2{ grid-template-columns: 1fr; }
  }

  label{ display:block; font-size:13px; color:var(--muted); }
  .field{
    margin-top:6px;
    width:100%;
    padding:12px 12px;
    font-size:16px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(255,255,255,.92);
    color:#111;
    outline:none;
  }
  select.field{ appearance:auto; }

  .stageWrap{
    padding:12px 14px 0;
  }
  canvas{
    width:100%;
    height:auto;
    display:block;
    margin:0 auto;
    background:#000;
    border-radius:14px;
  }

  .info{
    margin-top:12px;
    padding:14px;
    background:var(--panel2);
    border-top:1px solid rgba(255,255,255,.12);
    font-size:15px;
    line-height:1.45;
  }

  .dot{
    display:inline-block; width:14px; height:14px; border-radius:50%; margin-right:8px; vertical-align:-2px;
  }
  .dot.blue{ background:var(--blue); }
  .dot.orange{ background:var(--orange); }
  .dot.white{ background:#fff; }
  .muted{ color:rgba(234,241,255,.72); }
</style>
</head>

<body>
<header>
  <h1>üîÑ Analyse de vibrations ‚Äî Poulies & courroie</h1>
</header>

<div class="panel">
  <label>RPM moteur (menante)
    <input id="rpm" class="field" type="number" inputmode="decimal" value="1200" min="0" step="1">
  </label>

  <label>Syst√®me d‚Äôunit√©s
    <select id="unit" class="field">
      <option value="metric">M√©trique (mm)</option>
      <option value="imperial">Imp√©rial (po)</option>
    </select>
  </label>

  <div class="row2">
    <label>√ò poulie menante <span class="muted" id="u1">(mm)</span>
      <input id="d1" class="field" type="number" inputmode="decimal" value="100" min="0.01" step="0.01">
    </label>

    <label>√ò poulie men√©e <span class="muted" id="u2">(mm)</span>
      <input id="d2" class="field" type="number" inputmode="decimal" value="400" min="0.01" step="0.01">
    </label>
  </div>

  <label>Distance centre-√†-centre (C-C) <span class="muted" id="u3">(mm)</span>
    <input id="cc" class="field" type="number" inputmode="decimal" value="320" min="0.01" step="0.01">
  </label>
</div>

<div class="stageWrap">
  <canvas id="scene"></canvas>
</div>

<div class="info" id="info"></div>

<script>
(() => {
  const canvas = document.getElementById("scene");
  const ctx = canvas.getContext("2d");

  const rpmEl = document.getElementById("rpm");
  const unitEl = document.getElementById("unit");
  const d1El = document.getElementById("d1");
  const d2El = document.getElementById("d2");
  const ccEl = document.getElementById("cc");
  const infoEl = document.getElementById("info");

  const u1 = document.getElementById("u1");
  const u2 = document.getElementById("u2");
  const u3 = document.getElementById("u3");

  // ---- constantes visuelles
  const BLUE = "#00a2ff";
  const ORANGE = "#ff9800";
  const BELT = "#7e7e7e";
  const MARK = "#ffffff";

  // ---- temps ma√Ætre (comme ton Python)
  let lastTS = null;
  let t = 0;                 // secondes
  const TIME_SLOWDOWN = 1.0; // tu peux mettre 2,3,6 si tu veux plus lent

  // ---- helpers
  const TAU = Math.PI * 2;
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function mod2pi(a){
    a = a % TAU;
    if (a < 0) a += TAU;
    return a;
  }

  // Long arc helper (on force l‚Äôarc "ext√©rieur" long)
  function arcLong(cx, cy, r, start, end){
    start = mod2pi(start);
    end = mod2pi(end);
    let delta = end - start;
    if (delta < 0) delta += TAU;      // delta dans [0,2œÄ)
    const anticlockwise = (delta <= Math.PI); // si c‚Äôest le court, on prend l‚Äôautre sens = long
    ctx.arc(cx, cy, r, start, end, anticlockwise);
  }

  function setCanvasSize(){
    // Canvas responsive + retina
    const maxW = Math.min(window.innerWidth - 28, 760);
    const w = Math.max(320, maxW);
    const h = Math.round(w * 0.62); // ratio stable

    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // rep√®re en "px CSS"
  }

  // Unit conversion: on travaille en mm en interne
  const IN_TO_MM = 25.4;
  function getInputsMM(){
    const rpm = Math.max(0, +rpmEl.value || 0);

    const unit = unitEl.value;
    let d1 = +d1El.value || 0;
    let d2 = +d2El.value || 0;
    let cc = +ccEl.value || 0;

    if(unit === "imperial"){
      d1 *= IN_TO_MM;
      d2 *= IN_TO_MM;
      cc *= IN_TO_MM;
    }
    // s√©curit√©s
    d1 = Math.max(0.01, d1);
    d2 = Math.max(0.01, d2);
    cc = Math.max(0.01, cc);

    return { rpm, d1, d2, cc, unit };
  }

  function updateUnitLabels(){
    const unit = unitEl.value;
    const lab = unit === "imperial" ? "(po)" : "(mm)";
    u1.textContent = lab;
    u2.textContent = lab;
    u3.textContent = lab;
  }

  // conversion automatique des champs quand tu changes unit√© (pour garder les m√™mes dimensions physiques)
  function convertDisplayedValues(oldUnit, newUnit){
    if(oldUnit === newUnit) return;
    const factor = (oldUnit === "metric" && newUnit === "imperial") ? (1/IN_TO_MM)
                 : (oldUnit === "imperial" && newUnit === "metric") ? IN_TO_MM
                 : 1;

    d1El.value = (+d1El.value * factor).toFixed(3).replace(/\.?0+$/,'');
    d2El.value = (+d2El.value * factor).toFixed(3).replace(/\.?0+$/,'');
    ccEl.value = (+ccEl.value * factor).toFixed(3).replace(/\.?0+$/,'');
  }

  function drawFrame(dt){
    // dt en secondes (limit√© pour √©viter sauts si Safari "freeze")
    dt = clamp(dt, 0, 0.05);
    t += dt / TIME_SLOWDOWN;

    const W = parseFloat(canvas.style.width);
    const H = parseFloat(canvas.style.height);

    // fond
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    const { rpm, d1, d2, cc, unit } = getInputsMM();

    // cin√©matique (comme python) : vitesse lin√©aire courroie constante
    const f1 = rpm / 60;               // Hz
    const rpm2 = rpm * (d1 / d2);
    const f2 = rpm2 / 60;

    const w1 = TAU * f1;               // rad/s
    const w2 = TAU * f2;

    // angles (pilot√©s par t, pas par +=)
    const ang1 = -w1 * t;
    const ang2 = -w2 * t;

    // rayon "physique" mm
    const r1mm = d1 / 2;
    const r2mm = d2 / 2;

    // IMPORTANT: g√©om√©trie possible uniquement si cc >= |r2-r1| + marge
    const minCC = Math.abs(r2mm - r1mm) + 1; // +1mm de marge
    const ccSafe = Math.max(cc, minCC);

    // Mise √† l‚Äô√©chelle pour tenir dans le canvas
    const margin = 28;
    const usableW = W - 2*margin;
    const usableH = H - 2*margin;

    // on veut tenir: largeur ‚âà cc + r1 + r2, hauteur ‚âà 2*max(r1,r2)
    const scaleW = usableW / (ccSafe + r1mm + r2mm);
    const scaleH = usableH / (2 * Math.max(r1mm, r2mm));
    const s = Math.max(0.05, Math.min(scaleW, scaleH));

    const r1 = r1mm * s;
    const r2 = r2mm * s;
    const C  = ccSafe * s;

    const x1 = margin + r1;
    const x2 = x1 + C;
    const y  = H / 2;

    // ---- COURROIE (tangence externe stable)
    // phi = acos((r2 - r1) / C)
    const ratio = clamp((r2 - r1) / C, -1, 1);
    const phi = Math.acos(ratio);

    // angles des points de tangence (centres align√©s horizontalement)
    const aL_top = +phi;
    const aL_bot = -phi;

    const aR_top = Math.PI - phi;
    const aR_bot = Math.PI + phi;

    const Ltop = { x: x1 + r1*Math.cos(aL_top), y: y + r1*Math.sin(aL_top) };
    const Lbot = { x: x1 + r1*Math.cos(aL_bot), y: y + r1*Math.sin(aL_bot) };
    const Rtop = { x: x2 + r2*Math.cos(aR_top), y: y + r2*Math.sin(aR_top) };
    const Rbot = { x: x2 + r2*Math.cos(aR_bot), y: y + r2*Math.sin(aR_bot) };

    ctx.strokeStyle = BELT;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(Ltop.x, Ltop.y);
    ctx.lineTo(Rtop.x, Rtop.y);
    // arc sur grande poulie (ext√©rieur long)
    arcLong(x2, y, r2, aR_top, aR_bot);
    ctx.lineTo(Lbot.x, Lbot.y);
    // arc sur petite poulie (ext√©rieur long)
    arcLong(x1, y, r1, aL_bot, aL_top);
    ctx.stroke();

    // ---- POULIES
    function drawPulley(cx, cy, r, color, ang){
      // cercle
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TAU);
      ctx.stroke();

      // marqueur sur poulie (couleur poulie)
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(cx + (r-4)*Math.cos(ang), cy + (r-4)*Math.sin(ang), 5, 0, TAU);
      ctx.fill();
    }

    drawPulley(x1, y, r1, BLUE, ang1);
    drawPulley(x2, y, r2, ORANGE, ang2);

    // ---- POINT BLANC "sur la courroie" (optionnel, mais stable)
    // On le fait avancer avec la vitesse lin√©aire: v = w1*r1 (px/s)
    const v = Math.abs(w1) * r1;          // px/s
    const beltLength = (Math.hypot(Rtop.x-Ltop.x, Rtop.y-Ltop.y)) +
                       (Math.hypot(Rbot.x-Lbot.x, Rbot.y-Lbot.y)) +
                       (r1*(TAU - 2*phi)) +
                       (r2*(TAU - 2*phi)); // approx longueur totale (ext√©rieur)
    const sPos = (v * t) % beltLength;

    // on parcourt le chemin (top line -> right arc -> bottom line -> left arc)
    function lerp(p, q, u){ return { x: p.x + (q.x-p.x)*u, y: p.y + (q.y-p.y)*u }; }
    let rem = sPos;
    let P = {x:Ltop.x, y:Ltop.y};

    const lenTop = Math.hypot(Rtop.x-Ltop.x, Rtop.y-Ltop.y);
    const lenBot = Math.hypot(Lbot.x-Rbot.x, Lbot.y-Rbot.y);
    const lenArcR = r2*(TAU - 2*phi);
    const lenArcL = r1*(TAU - 2*phi);

    if(rem <= lenTop){
      P = lerp(Ltop, Rtop, rem/lenTop);
    } else {
      rem -= lenTop;
      if(rem <= lenArcR){
        // arc long sur droite: de aR_top -> aR_bot dans le sens "long"
        // on prend un param√®tre u sur [0,1] et on avance sur l‚Äôangle long
        const u = rem/lenArcR;
        // angle long = TAU - 2*phi
        const ang = aR_top - u*(TAU - 2*phi); // (sens long)
        P = { x: x2 + r2*Math.cos(ang), y: y + r2*Math.sin(ang) };
      } else {
        rem -= lenArcR;
        if(rem <= lenBot){
          P = lerp(Rbot, Lbot, rem/lenBot);
        } else {
          rem -= lenBot;
          const u = (lenArcL <= 0) ? 0 : rem/lenArcL;
          const ang = aL_bot - u*(TAU - 2*phi); // sens long
          P = { x: x1 + r1*Math.cos(ang), y: y + r1*Math.sin(ang) };
        }
      }
    }

    ctx.fillStyle = MARK;
    ctx.beginPath();
    ctx.arc(P.x, P.y, 5, 0, TAU);
    ctx.fill();

    // ---- INFOS + unit√©s
    let unitLabel = (unit === "imperial") ? "po" : "mm";

    // vitesse lin√©aire courroie (comme ton Python): v = rpm * œÄ * D
    // en unit√©/min de l‚Äôunit√© choisie:
    let v_unit_per_min;
    if(unit === "imperial"){
      // D en pouces (donc on reconvertit)
      const d1_in = d1 / IN_TO_MM;
      v_unit_per_min = rpm * Math.PI * d1_in; // po/min
    } else {
      v_unit_per_min = rpm * Math.PI * d1;    // mm/min
    }

    infoEl.innerHTML = `
      <div><span class="dot blue"></span><b>Menante</b> : ${rpm.toFixed(0)} RPM / ${f1.toFixed(2)} Hz</div>
      <div><span class="dot orange"></span><b>Men√©e</b> : ${rpm2.toFixed(0)} RPM / ${f2.toFixed(2)} Hz</div>
      <div class="muted" style="margin-top:6px;">
        <span class="dot white"></span>Vitesse lin√©aire courroie ‚âà ${v_unit_per_min.toFixed(1)} ${unitLabel}/min
        ${cc < minCC ? `<br>‚ö†Ô∏è C-C trop petit ‚Üí corrig√© automatiquement √† ${(unit==="imperial"?(minCC/IN_TO_MM):minCC).toFixed(2)} ${unitLabel} (sinon g√©om√©trie impossible).` : ``}
      </div>
    `;
  }

  function loop(ts){
    if(lastTS === null) lastTS = ts;
    const dt = (ts - lastTS) / 1000;
    lastTS = ts;
    drawFrame(dt);
    requestAnimationFrame(loop);
  }

  // Events
  let prevUnit = unitEl.value;
  unitEl.addEventListener("change", () => {
    const newUnit = unitEl.value;
    convertDisplayedValues(prevUnit, newUnit);
    prevUnit = newUnit;
    updateUnitLabels();
  });

  window.addEventListener("resize", () => setCanvasSize());

  // init
  updateUnitLabels();
  setCanvasSize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>