<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Courroie & poulies — trajectoire correcte</title>

<style>
body{
  margin:0;
  background:#0b1436;
  font-family:Arial,system-ui,sans-serif;
  color:#eaf1ff;
}
header{
  padding:14px;
  font-size:18px;
  font-weight:700;
}
.stage{
  padding:12px;
}
canvas{
  width:100%;
  max-width:720px;
  display:block;
  margin:auto;
  background:#000;
  border-radius:14px;
}
</style>
</head>

<body>
<header>Courroie & poulies — trajectoire correcte</header>

<div class="stage">
  <canvas id="scene"></canvas>
</div>

<script>
(() => {

const canvas = document.getElementById("scene");
const ctx = canvas.getContext("2d");

const TAU = Math.PI * 2;
let t = 0;
let lastTS = null;

function resize(){
  const w = Math.min(innerWidth - 24, 720);
  const h = w * 0.45;
  const dpr = Math.min(3, devicePixelRatio || 1);

  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  canvas.width = w * dpr;
  canvas.height = h * dpr;

  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

function lerp(a,b,u){
  return { x:a.x+(b.x-a.x)*u, y:a.y+(b.y-a.y)*u };
}

function loop(ts){
  if(!lastTS) lastTS = ts;
  const dt = (ts - lastTS)/1000;
  lastTS = ts;
  t += dt * 0.6;
  draw();
  requestAnimationFrame(loop);
}

function draw(){
  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,W,H);

  // paramètres fixes (test visuel)
  const rSmall = 45;
  const rBig   = 85;
  const C      = 220;

  const xL = 90;
  const xR = xL + C;
  const y  = H/2;

  const phi = Math.acos((rBig - rSmall)/C);

  const aLt =  phi;
  const aLb = -phi;
  const aRt = Math.PI - phi;
  const aRb = Math.PI + phi;

  const Ltop = { x:xL + rSmall*Math.cos(aLt), y:y + rSmall*Math.sin(aLt) };
  const Lbot = { x:xL + rSmall*Math.cos(aLb), y:y + rSmall*Math.sin(aLb) };
  const Rtop = { x:xR + rBig*Math.cos(aRt),   y:y + rBig*Math.sin(aRt) };
  const Rbot = { x:xR + rBig*Math.cos(aRb),   y:y + rBig*Math.sin(aRb) };

  // === COURROIE ===
  ctx.strokeStyle="#9a9a9a";
  ctx.lineWidth=4;
  ctx.lineCap="butt";      // ✅ IMPORTANT
  ctx.lineJoin="miter";    // ✅ IMPORTANT

  ctx.beginPath();
  ctx.moveTo(Ltop.x, Ltop.y);
  ctx.lineTo(Rtop.x, Rtop.y);

  // grande poulie (arc long)
  ctx.arc(
    xR, y, rBig,
    aRt + 0.002,            // ✅ micro-offset anti-trace
    aRb - 0.002,
    false
  );

  ctx.lineTo(Lbot.x, Lbot.y);

  // petite poulie (arc court)
  ctx.arc(
    xL, y, rSmall,
    aLb + 0.002,
    aLt - 0.002,
    false
  );
  ctx.stroke();

  // === POULIES ===
  function drawPulley(cx,cy,r,color){
    ctx.strokeStyle=color;
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,TAU);
    ctx.stroke();
  }

  drawPulley(xL,y,rSmall,"#00a2ff");
  drawPulley(xR,y,rBig,"#ff9800");

  // === POINT SUR COURROIE ===
  const lenTop = Math.hypot(Rtop.x-Ltop.x, Rtop.y-Ltop.y);
  const lenBot = Math.hypot(Lbot.x-Rbot.x, Lbot.y-Rbot.y);
  const lenArcR = rBig*(TAU - 2*phi);
  const lenArcL = rSmall*(2*phi);
  const beltLen = lenTop + lenArcR + lenBot + lenArcL;

  let s = (t*120) % beltLen;
  let P;

  if(s <= lenTop){
    P = lerp(Ltop, Rtop, s/lenTop);
  }
  else if((s -= lenTop) <= lenArcR){
    const u = s/lenArcR;
    const a = aRt - u*(TAU - 2*phi);
    P = { x:xR + rBig*Math.cos(a), y:y + rBig*Math.sin(a) };
  }
  else if((s -= lenArcR) <= lenBot){
    P = lerp(Rbot, Lbot, s/lenBot);
  }
  else{
    s -= lenBot;
    const u = s/lenArcL;
    const a = aLb + u*(2*phi);
    P = { x:xL + rSmall*Math.cos(a), y:y + rSmall*Math.sin(a) };
  }

  ctx.fillStyle="#fff";
  ctx.beginPath();
  ctx.arc(P.x,P.y,5,0,TAU);
  ctx.fill();
}

requestAnimationFrame(loop);
})();
</script>
</body>
</html>