<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Courroie & poulies ‚Äî trajectoire correcte</title>

<style>
:root{
  --bg:#0b1436;
  --panel:#101a40;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.70);
  --blue:#00a2ff;
  --orange:#ff9800;
  --belt:#9a9a9a;
  --btn:#1c2b6a;
  --bad:#ff4d4d;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial,system-ui,sans-serif; }
header{ padding:10px 14px; font-size:16px; font-weight:700; }
.controls{ padding:10px 14px; display:grid; grid-template-columns:repeat(2,1fr); gap:8px; }
.controls label{ font-size:12px; color:var(--muted); }
.controls input,.controls select{ width:100%; padding:4px 6px; font-size:13px; border-radius:8px; border:none; }
.controls .full{ grid-column:1/-1; }
.buttons{ display:flex; gap:10px; padding:0 14px 10px; flex-wrap:wrap; }
button{ flex:1; min-width:120px; padding:10px; font-size:15px; border:none; border-radius:12px; background:var(--btn); color:white; }
.stage{ padding:10px 14px; }
canvas{ width:100%; background:#000; border-radius:12px; display:block; }
#spectrum{ background:#05080f; touch-action:none; } /* important pour pan iPhone */
.results{ padding:10px 14px 18px; font-size:14px; line-height:1.45; }
.bad{color:var(--bad); font-weight:700;}
.small{ font-size:12px; opacity:.75; margin-top:6px;}

/* ===== Sorties int√©gr√©es (r√©sum√© vitesses) ===== */
.outputBox{
  background:rgba(255,255,255,0.08);
  border-radius:12px;
  padding:10px;
  font-size:13px;
  line-height:1.4;
}
.outputBox b{ color:#cfe2ff; }

/* ===== MESSAGE ROTATION PAYSAGE ===== */
.rotate-warning{
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(5,8,15,0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 24px;
  font-size: 18px;
  font-weight: 700;
  color: #eaf1ff;
  pointer-events: none;
}
.rotate-warning span{
  display: block;
  font-size: 14px;
  font-weight: 400;
  opacity: 0.85;
  margin-top: 10px;
}

/* emp√™che le scroll quand plein √©cran spectre */
.lock-scroll{ overflow: hidden; height: 100vh; }

/* canvas spectre en plein √©cran */
canvas.spectrum-only{
  position: fixed;
  inset: 0;
  width: 100vw !important;
  height: 100vh !important;
  border-radius: 0 !important;
  z-index: 9999;
}

/* ===== MODE SPECTRE : cacher le reste (sans cacher le parent du canvas) ===== */
body.spectrum-mode header,
body.spectrum-mode .controls,
body.spectrum-mode .buttons,
body.spectrum-mode #sceneStage,
body.spectrum-mode #info{
  display:none !important;
}
/* garder le spectre visible */
body.spectrum-mode #specStage{
  display:block !important;
  padding:0 !important;
}
body.spectrum-mode{
  margin:0;
  padding:0;
  overflow:hidden;
  height:100vh;
}
</style>
</head>

<body>
<header>üîÑ Courroie & poulies ‚Äî trajectoire correcte (open belt)</header>

<div class="controls">
  <label>RPM moteur <input id="rpm" type="number" inputmode="decimal" value="1500"></label>

  <label>Unit√©s
    <select id="unit">
      <option value="imperial" selected>po</option>
      <option value="metric">mm</option>
    </select>
  </label>

  <label>√ò menante <input id="d1" type="number" inputmode="decimal" value="4"></label>
  <label>√ò men√©e <input id="d2" type="number" inputmode="decimal" value="9"></label>
  <label class="full">C-C <input id="cc" type="number" inputmode="decimal" value="21"></label>

  <div class="outputBox full">
    <div><b>Menante</b> : <span id="out-rpm1">‚Äî</span> RPM | <span id="out-cpm1">‚Äî</span> CPM | <span id="out-hz1">‚Äî</span> Hz</div>
    <div><b>Men√©e</b> : <span id="out-rpm2">‚Äî</span> RPM | <span id="out-cpm2">‚Äî</span> CPM | <span id="out-hz2">‚Äî</span> Hz</div>
    <div><b>Courroie</b> : <span id="out-hzbelt">‚Äî</span> Hz | <span id="out-fpm">‚Äî</span> ft/min | <span id="out-strobe">‚Äî</span> FPM</div>
    <div><b>Longueur courroie</b> : <span id="out-length">‚Äî</span></div>
    <div class="small">Note : ‚ÄúFPM‚Äù ici = <b>Feet/min</b> pour la vitesse lin√©aire, et ‚ÄúFPM (strobe)‚Äù = <b>Flash/min</b> (‚âà Hz√ó60).</div>
  </div>

  <div class="full">
    <label class="full">
      D√©faut simul√©
      <select id="fault">
        <option value="none">Aucun (normal)</option>
        <option value="unbalance">Balourd (1√ó)</option>
        <option value="misalign">D√©salignement (1√ó & 2√ó)</option>
        <option value="looseness">Jeu m√©canique / Looseness (1√ó,2√ó,3√ó)</option>
        <option value="belt">D√©faut de courroie (1√ó & 2√ó courroie)</option>
        <option value="slip">Glissement courroie (bande qui ‚Äúflotte‚Äù)</option>
        <option value="bearing">D√©faut roulement (harmoniques hautes)</option>
        <option value="resonance">R√©sonance structurelle (pic large)</option>
        <option value="all">TOUT</option>
      </select>
    </label>

    <label style="display:block;margin-bottom:4px;">Ralenti (plus grand = plus lent)</label>
    <input id="slow" type="range" min="1" max="20" value="8">
  </div>
</div>

<div class="buttons">
  <button id="play">Play</button>
  <button id="pause">Pause</button>
  <button id="reset">Reset</button>
  <button id="fs">Full screen (spectre)</button>
</div>

<div class="stage" id="sceneStage"><canvas id="scene"></canvas></div>
<div class="stage" id="specStage"><canvas id="spectrum"></canvas></div>

<div class="results" id="info"></div>

<div id="rotateWarn" class="rotate-warning" style="display:none;">
  üîÑ Tournez votre t√©l√©phone en mode paysage
  <span>Pour une meilleure lecture du spectre</span>
</div>

<script>
(() => {

  /* =========================================================
     CONSTANTES / OUTILS
     ========================================================= */
  const TAU = Math.PI * 2;
  const IN_TO_MM = 25.4;

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));

  function dprNow(){
    return Math.min(3, window.devicePixelRatio || 1);
  }

  /* =========================================================
     √âTAT GLOBAL
     ========================================================= */
  let running   = false;  // anim√© uniquement si Play
  let lastTS    = null;

  // temps ‚Äúanimation courroie + poulies‚Äù
  let t = 0;

  // temps ‚Äúspectre‚Äù : DOIT avancer uniquement si running
  let specTime = 0;

  // angles poulies
  let ang1 = 0;
  let ang2 = 0;

  // largeur verrouill√©e (mise en page stable)
  let lockedWidth = null;

  // mode plein √©cran spectre
  let spectrumFS = false;

  /* =========================================================
     DOM
     ========================================================= */
  const canvas    = document.getElementById("scene");
  const ctx       = canvas.getContext("2d");

  const specCanvas= document.getElementById("spectrum");
  const specCtx   = specCanvas.getContext("2d");

  const rpmEl   = document.getElementById("rpm");
  const d1El    = document.getElementById("d1");
  const d2El    = document.getElementById("d2");
  const ccEl    = document.getElementById("cc");
  const unitEl  = document.getElementById("unit");
  const slowEl  = document.getElementById("slow");
  const faultEl = document.getElementById("fault");

  const infoEl     = document.getElementById("info");
  const rotateWarn = document.getElementById("rotateWarn");

  const outLength  = document.getElementById("out-length");
  const outRPM1    = document.getElementById("out-rpm1");
  const outCPM1    = document.getElementById("out-cpm1");
  const outHZ1     = document.getElementById("out-hz1");
  const outRPM2    = document.getElementById("out-rpm2");
  const outCPM2    = document.getElementById("out-cpm2");
  const outHZ2     = document.getElementById("out-hz2");
  const outHZBelt  = document.getElementById("out-hzbelt");
  const outFPM     = document.getElementById("out-fpm");
  const outStrobe  = document.getElementById("out-strobe");

  const playBtn  = document.getElementById("play");
  const pauseBtn = document.getElementById("pause");
  const resetBtn = document.getElementById("reset");
  const fsBtn    = document.getElementById("fs");

  /* =========================================================
     VUE SPECTRE (pan Hz)
     ========================================================= */
  const spectrumView = {
    minHz: 0,
    spanHz: 50,
    maxHz: 300
  };

  let isPanning   = false;
  let panStartX   = 0;
  let panStartMin = 0;

  /* =========================================================
     LECTURE / VALIDATION DES ENTR√âES
     ========================================================= */
  function readInputs(){
    let rpm = parseFloat(rpmEl.value);
    let d1  = parseFloat(d1El.value);
    let d2  = parseFloat(d2El.value);
    let cc  = parseFloat(ccEl.value);

    if(!isFinite(rpm) || !isFinite(d1) || !isFinite(d2) || !isFinite(cc)) return null;
    if(rpm <= 0 || d1 <= 0 || d2 <= 0 || cc <= 0) return null;

    // conversion vers mm si imp√©rial
    if(unitEl.value === "imperial"){
      d1 *= IN_TO_MM;
      d2 *= IN_TO_MM;
      cc *= IN_TO_MM;
    }

    return { rpm, d1mm:d1, d2mm:d2, ccmm:cc };
  }

  function validateGeometryOpenBelt(inp){
    // r√®gle minimale : C > |R2 - R1|
    const r1 = inp.d1mm / 2;
    const r2 = inp.d2mm / 2;
    const minCC = Math.abs(r2 - r1);

    if(inp.ccmm <= minCC){
      const minTxt = (unitEl.value === "imperial")
        ? (minCC / IN_TO_MM).toFixed(2) + " po"
        : minCC.toFixed(1) + " mm";

      return {
        ok:false,
        html: `
          <div class="bad">‚õî G√©om√©trie impossible (open belt)</div>
          <div>C-C doit √™tre <b>&gt; |R2 ‚àí R1|</b>.</div>
          <div class="small">Minimum = ${minTxt}</div>
        `
      };
    }

    // (optionnel) suggestion ‚Äúconfort‚Äù : C > (R1+R2) est g√©n√©ralement plus r√©aliste
    // mais on n‚Äôemp√™che pas (tu voulais seulement incoh√©rence math√©matique)
    return { ok:true, html:"" };
  }

  /* =========================================================
     CALCULS (courroie, vitesses, longueur)
     ========================================================= */
  function beltLengthOpenBeltMM(D1mm, D2mm, Cmm){
    // L = 2C + œÄ/2(D1 + D2) + (D2-D1)^2/(4C)
    return 2*Cmm + (Math.PI/2)*(D1mm + D2mm) + ((D2mm - D1mm)**2)/(4*Cmm);
  }

  function beltLinearSpeed_mm_s(d1mm, rpm){
    // v = œÄ D (rpm/60)   (mm/s si D en mm)
    return Math.PI * d1mm * (rpm/60);
  }

  /* =========================================================
     G√âOM√âTRIE TRAJECTOIRE COURROIE (points)
     ========================================================= */
  function buildBeltPath(x1,y1,r1, x2,y2,r2){
    const C = Math.hypot(x2-x1, y2-y1);
    const R = Math.max(r1,r2);
    const r = Math.min(r1,r2);

    // open-belt : phi = acos((R-r)/C)
    const phi = Math.acos(clamp((R - r)/C, -1, 1));

    const aL_top =  phi;
    const aL_bot = -phi;
    const aR_top = Math.PI - phi;
    const aR_bot = Math.PI + phi;

    const Ltop = {x:x1 + r1*Math.cos(aL_top), y:y1 + r1*Math.sin(aL_top)};
    const Lbot = {x:x1 + r1*Math.cos(aL_bot), y:y1 + r1*Math.sin(aL_bot)};
    const Rtop = {x:x2 + r2*Math.cos(aR_top), y:y2 + r2*Math.sin(aR_top)};
    const Rbot = {x:x2 + r2*Math.cos(aR_bot), y:y2 + r2*Math.sin(aR_bot)};

    // sweeps
    const sweepRight = -(TAU - 2*phi); // arc long
    const sweepLeft  = -(2*phi);       // arc court (sens coh√©rent visuellement ici)

    function arcPoints(cx,cy,r, aStart, sweep){
      const absSweep = Math.abs(sweep);
      const steps = Math.max(22, Math.floor((absSweep * r) / 9));
      const pts = [];
      for(let i=0;i<=steps;i++){
        const u = i/steps;
        const a = aStart + sweep*u;
        pts.push({x:cx + r*Math.cos(a), y:cy + r*Math.sin(a)});
      }
      return pts;
    }

    // boucle : Ltop -> Rtop -> arc droite -> Lbot -> arc gauche -> Ltop
    const clean = [];
    clean.push(Ltop, Rtop);

    const arcR = arcPoints(x2,y2,r2, aR_top, sweepRight);
    for(let i=1;i<arcR.length;i++) clean.push(arcR[i]); // finit sur Rbot

    clean.push(Lbot); // ligne Rbot -> Lbot

    const arcL = arcPoints(x1,y1,r1, aL_bot, sweepLeft);
    for(let i=1;i<arcL.length;i++) clean.push(arcL[i]); // finit sur Ltop

    return { pts: clean, phi };
  }

  function polylineLength(pts){
    let L=0;
    for(let i=1;i<pts.length;i++){
      const dx = pts[i].x-pts[i-1].x;
      const dy = pts[i].y-pts[i-1].y;
      L += Math.hypot(dx,dy);
    }
    return L;
  }

  function pointAt(pts, s){
    let acc = 0;
    for(let i=1;i<pts.length;i++){
      const a = pts[i-1], b = pts[i];
      const seg = Math.hypot(b.x-a.x, b.y-a.y);
      if(acc + seg >= s){
        const u = (s - acc)/seg;
        return { x: a.x + (b.x-a.x)*u, y: a.y + (b.y-a.y)*u };
      }
      acc += seg;
    }
    return pts[pts.length-1];
  }

  /* =========================================================
     RENDER POU LIE
     ========================================================= */
  function drawPulley(cx, cy, r, col, angle){
    ctx.strokeStyle = col;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, TAU);
    ctx.stroke();

    // rep√®re de rotation
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(
      cx + (r - 6) * Math.cos(angle),
      cy + (r - 6) * Math.sin(angle),
      3,
      0,
      TAU
    );
    ctx.fill();
  }

  /* =========================================================
     SPECTRE : PICS (BLOC COMPLET, LIVE UNIQUEMENT EN PLAY)
     ========================================================= */
  function buildPeaks(fMotor, fBelt, time, fault){
    // IMPORTANT : time est ‚ÄúspecTime‚Äù
    // => specTime n‚Äôavance QUE si running
    // => donc ‚Äúlive‚Äù seulement quand Play.

    const peaks = [];

    // ===== bases temps (3 vitesses) =====
    const t1 = time;
    const t2 = time * 1.7;
    const t3 = time * 2.3;

    // ===== fr√©quences moteur =====
    const f1 = fMotor;        // 1√ó
    const f2 = fMotor * 2;    // 2√ó
    const f3 = fMotor * 3;    // 3√ó
    const f4 = fMotor * 4;    // 4√ó

    // ===== amplitudes vivantes (quand Play) =====
    const a_base = 1.00 + 0.10*Math.sin(t1);
    const a_mid  = 0.70 + 0.15*Math.sin(t2);
    const a_high = 0.45 + 0.20*Math.sin(t3);

    // ===================================================
    // 0) NORMAL (toujours pr√©sent)
    // ===================================================
    peaks.push({ hz: f1, amp: a_base, col:"#00a2ff", label:"1√ó moteur" });

    // (petit 2√ó de r√©f√©rence en mode normal)
    if(fault === "none"){
      peaks.push({ hz: f2, amp: 0.35 + 0.05*Math.sin(t2), col:"#5fbfff", label:"2√ó moteur" });
    }

    // ===================================================
    // 1) BALOURD : 1√ó dominant + un peu de bruit
    // ===================================================
    if(fault === "unbalance" || fault === "all"){
      peaks.push(
        { hz: f1, amp: 1.85 + 0.25*Math.sin(t1), col:"#ff5555", label:"Balourd (1√ó)" },
        { hz: f2, amp: 0.35 + 0.10*Math.sin(t2), col:"#ff8888", label:"Harmonique (2√ó)" }
      );
    }

    // ===================================================
    // 2) D√âSALIGNEMENT : 1√ó + 2√ó plus √©lev√©s
    // ===================================================
    if(fault === "misalign" || fault === "all"){
      peaks.push(
        { hz: f1, amp: 1.10 + 0.20*Math.sin(t2), col:"#ff9800", label:"D√©salignement (1√ó)" },
        { hz: f2, amp: 1.55 + 0.25*Math.sin(t1), col:"#ff9800", label:"D√©salignement (2√ó)" },
        { hz: f3, amp: 0.55 + 0.10*Math.sin(t3), col:"#ffb74d", label:"3√ó (souvent pr√©sent)" }
      );
    }

    // ===================================================
    // 3) JEU / LOOSENESS : 1√ó,2√ó,3√ó + sous-harmonique parfois
    // ===================================================
    if(fault === "looseness" || fault === "all"){
      peaks.push(
        { hz: f1*0.5, amp: 0.65 + 0.15*Math.sin(t1*0.9), col:"#ffd54f", label:"0.5√ó (jeu)" },
        { hz: f1,     amp: 1.05 + 0.20*Math.sin(t1),     col:"#ffd54f", label:"Jeu 1√ó" },
        { hz: f2,     amp: 0.95 + 0.20*Math.sin(t2),     col:"#ffd54f", label:"Jeu 2√ó" },
        { hz: f3,     amp: 0.80 + 0.20*Math.sin(t3),     col:"#ffd54f", label:"Jeu 3√ó" }
      );
    }

    // ===================================================
    // 4) D√âFAUT COURROIE : fBelt + 2√ófBelt + sidebands (¬±1√ó moteur)
    // ===================================================
    if(fault === "belt" || fault === "all"){
      const fb = fBelt;

      peaks.push(
        { hz: fb,     amp: 1.20 + 0.20*Math.sin(t1), col:"#ffffff", label:"Courroie (1√ó)" },
        { hz: fb*2,   amp: 0.65 + 0.15*Math.sin(t2), col:"#bbbbbb", label:"Courroie (2√ó)" }
      );

      // sidebands autour de la courroie (p√©dagogique)
      peaks.push(
        { hz: Math.max(0, fb - f1), amp: 0.35 + 0.10*Math.sin(t2), col:"#e0e0e0", label:"SB (fb‚àí1√ó)" },
        { hz: fb + f1,              amp: 0.35 + 0.10*Math.sin(t3), col:"#e0e0e0", label:"SB (fb+1√ó)" }
      );
    }

    // ===================================================
    // 5) GLISSEMENT : la fr√©quence courroie ‚Äúflotte‚Äù (live) quand Play
    // ===================================================
    if(fault === "slip" || fault === "all"){
      const slip = 0.92 + 0.08*Math.sin(t1*1.5); // 0.84..1.00
      peaks.push(
        { hz: fBelt * slip, amp: 0.95 + 0.20*Math.sin(t2), col:"#ffcc00", label:"Glissement (fb√óslip)" },
        { hz: fBelt,        amp: 0.45 + 0.10*Math.sin(t3), col:"#fff59d", label:"fb (r√©f√©rence)" }
      );
    }

    // ===================================================
    // 6) ROULEMENT (g√©n√©ral) : pics ‚Äúhautes fr√©quences‚Äù + large bruit
    //     (ici on simule des familles BPFO / BPFI / BSF
    //      sans calcul r√©el des facteurs g√©om√©triques)
    // ===================================================
    if(fault === "bearing" || fault === "all"){
      // facteurs ‚Äútypiques‚Äù (p√©dagogiques)
      const bpfo = f1 * 4.0;   // ~3‚Äì5√ó
      const bpfi = f1 * 5.2;   // ~4‚Äì6√ó
      const bsf  = f1 * 2.6;   // ~2‚Äì3√ó

      peaks.push(
        { hz: bpfo,        amp: 0.70 + 0.25*Math.sin(t3), col:"#c77dff", label:"Roulement (BPFO)" },
        { hz: bpfi,        amp: 0.60 + 0.25*Math.sin(t2), col:"#c77dff", label:"Roulement (BPFI)" },
        { hz: bsf,         amp: 0.45 + 0.20*Math.sin(t1), col:"#d7a7ff", label:"Roulement (BSF)" },
        { hz: bpfo*2,      amp: 0.35 + 0.10*Math.sin(t1), col:"#b388ff", label:"BPFO√ó2" },
        { hz: bpfi*2,      amp: 0.30 + 0.10*Math.sin(t2), col:"#b388ff", label:"BPFI√ó2" }
      );
    }

    // ===================================================
    // 7) R√âSONANCE : pic plus haut + ‚Äúlargeur‚Äù simul√©e par 3 pics proches
    // ===================================================
    if(fault === "resonance" || fault === "all"){
      const fr = fMotor * 2.6; // exemple
      peaks.push(
        { hz: fr - 0.8, amp: 1.10 + 0.20*Math.sin(t1), col:"#ff1744", label:"R√©sonance (fr‚àí)" },
        { hz: fr,       amp: 2.20 + 0.35*Math.sin(t1), col:"#ff1744", label:"R√©sonance (fr)" },
        { hz: fr + 0.8, amp: 1.00 + 0.20*Math.sin(t2), col:"#ff1744", label:"R√©sonance (fr+)" }
      );
    }

    // ===================================================
    // 8) ALL : ajoute aussi quelques harmoniques ‚Äúhaut‚Äù
    // ===================================================
    if(fault === "all"){
      peaks.push(
        { hz: f4, amp: a_highSZ(0.35, t2), col:"#90caf9", label:"4√ó moteur" },
        { hz: f1*6, amp: aSZ(0.25, t3), col:"#90caf9", label:"6√ó moteur" }
      );
    }

    return peaks;

    }
  /* =========================================================
     DESSIN SPECTRE
     ========================================================= */
  function drawSpectrum(hzMotor, hzBelt, time){
    const dpr = dprNow();
    const W = specCanvas.width  / dpr;
    const H = specCanvas.height / dpr;

    // ===== layout zone Hz =====
    const hzZoneHeight = 42;

    let hzZoneY;
    if(spectrumFS){
      hzZoneY = H - hzZoneHeight - 80;  // marge iOS fullscreen
    }else{
      hzZoneY = H - hzZoneHeight - 10;  // marge normal
    }
    hzZoneY = Math.max(80, hzZoneY);

    const gridTop    = 16;
    const gridBottom = hzZoneY - 10;
    const gridHeight = gridBottom - gridTop;

    // marge gauche mm/s
    const ampLabelWidth = 58;
    const plotLeft  = ampLabelWidth;
    const plotRight = W;
    const plotWidth = plotRight - plotLeft;

    // amplitude mm/s
    const AMP_MAX  = 10;
    const AMP_STEP = 2;

    // fen√™tre Hz visible
    const minHz = spectrumView.minHz;
    const maxHz = spectrumView.minHz + spectrumView.spanHz;
    const scaleX = plotWidth / (maxHz - minHz);

    // fond
    specCtx.clearRect(0,0,W,H);
    specCtx.fillStyle = "#05080f";
    specCtx.fillRect(0,0,W,H);

    // bande Hz
    specCtx.fillStyle = "rgba(0,162,255,0.15)";
    specCtx.fillRect(0, hzZoneY, W, hzZoneHeight);

    // r√®gle Hz
    specCtx.strokeStyle = "rgba(255,255,255,0.35)";
    specCtx.fillStyle   = "#eaf1ff";
    specCtx.font        = "11px Arial";
    specCtx.textAlign   = "center";
    specCtx.textBaseline= "top";

    const majorStep = 10;
    const minorStep = 5;

    for(let hz = Math.ceil(minHz / minorStep) * minorStep; hz <= maxHz; hz += minorStep){
      const x = plotLeft + (hz - minHz) * scaleX;
      const isMajor = (hz % majorStep === 0);

      specCtx.beginPath();
      specCtx.moveTo(x, hzZoneY);
      specCtx.lineTo(x, hzZoneY + (isMajor ? 12 : 6));
      specCtx.stroke();

      if(isMajor){
        specCtx.fillText(hz + " Hz", x, hzZoneY + 14);
      }
    }

    // grille verticale (Hz)
    specCtx.strokeStyle = "rgba(255,255,255,0.08)";
    for(let i=0;i<=8;i++){
      const x = plotLeft + i * plotWidth / 8;
      specCtx.beginPath();
      specCtx.moveTo(x, gridTop);
      specCtx.lineTo(x, gridBottom);
      specCtx.stroke();
    }

    // grille horizontale + mm/s √† gauche
    specCtx.strokeStyle = "rgba(255,255,255,0.12)";
    specCtx.fillStyle   = "#cfd6ff";
    specCtx.font        = "11px Arial";
    specCtx.textAlign   = "right";
    specCtx.textBaseline= "middle";

    for(let a=0; a<=AMP_MAX; a+=AMP_STEP){
      const y = gridBottom - (a / AMP_MAX) * gridHeight;

      specCtx.beginPath();
      specCtx.moveTo(plotLeft, y);
      specCtx.lineTo(plotRight, y);
      specCtx.stroke();

      specCtx.fillText(a + " mm/s", plotLeft - 6, y);
    }

    // ===== PICS =====
    const fault = faultEl.value || "none";
    const peaks = buildPeaks(hzMotor, hzBelt, time, fault);

    // dessin barres
    peaks.forEach(p=>{
      if(!isFinite(p.hz) || p.hz < minHz || p.hz > maxHz) return;

      const x = plotLeft + (p.hz - minHz) * scaleX;

      // conversion p√©dagogique : amp -> mm/s (ton facteur)
      const ampMMs = p.amp * 5;
      const h = (ampMMs / AMP_MAX) * gridHeight;
      const yTop = gridBottom - h;

      specCtx.strokeStyle = p.col;
      specCtx.lineWidth = 3;
      specCtx.beginPath();
      specCtx.moveTo(x, gridBottom);
      specCtx.lineTo(x, yTop);
      specCtx.stroke();

      // label
      specCtx.fillStyle = "#cfd6ff";
      specCtx.font = "12px Arial";
      specCtx.textAlign = "center";
      specCtx.textBaseline = "bottom";
      specCtx.fillText(p.label, x, Math.max(yTop - 6, gridTop + 14));
    });

    // axe
    specCtx.fillStyle = "#9aa5d6";
    specCtx.font = "12px Arial";
    specCtx.textAlign = "right";
    specCtx.textBaseline = "top";
    specCtx.fillText("Hz ‚Üí", W - 6, 6);
  }

  /* =========================================================
     RESIZE (sc√®ne + spectre) ‚Äî IMPORTANT (plein √©cran)
     ========================================================= */
  function resize(){
    const dpr = dprNow();

    // ---- sc√®ne (poulies) ----
    if(!lockedWidth){
      lockedWidth = Math.min(window.innerWidth - 24, 720);
    }
    const w = lockedWidth;
    const h = w * 0.55;

    canvas.style.width  = w + "px";
    canvas.style.height = h + "px";
    canvas.width  = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // ---- spectre ----
    let specW, specH;

    if(spectrumFS){
      // iOS : visualViewport donne la vraie taille visible
      const vv = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
      specW = vv.width;
      specH = vv.height;

      specCanvas.style.position = "fixed";
      specCanvas.style.left = "0";
      specCanvas.style.top  = "0";
      specCanvas.style.margin = "0";
      specCanvas.style.borderRadius = "0";
    }else{
      specW = w;
      specH = Math.max(220, h * 0.95);

      specCanvas.style.position = "relative";
      specCanvas.style.marginTop = "18px";
      specCanvas.style.borderRadius = "12px";
    }

    specCanvas.style.width  = specW + "px";
    specCanvas.style.height = specH + "px";
    specCanvas.width  = Math.round(specW * dpr);
    specCanvas.height = Math.round(specH * dpr);

    specCtx.setTransform(dpr,0,0,dpr,0,0);
    specCtx.imageSmoothingEnabled = false;
  }

  /* =========================================================
     MODE FULLSCREEN SPECTRE
     ========================================================= */
  function checkOrientation(){
    if(!spectrumFS){
      rotateWarn.style.display = "none";
      return;
    }
    const vv = window.visualViewport;
    const vw = vv ? vv.width  : window.innerWidth;
    const vh = vv ? vv.height : window.innerHeight;

    const isPortrait = vh > vw + 40; // marge anti faux positif
    rotateWarn.style.display = isPortrait ? "flex" : "none";
  }

  function toggleSpectrumFS(){
    spectrumFS = !spectrumFS;

    document.body.classList.toggle("spectrum-mode", spectrumFS);
    document.body.classList.toggle("lock-scroll", spectrumFS);
    specCanvas.classList.toggle("spectrum-only", spectrumFS);

    resize();
    checkOrientation();

    // redraw imm√©diat (m√™me en pause) avec specTime fig√©
    redrawSpectrumNow();
  }

  /* =========================================================
     REDRAW SPECTRE (m√™me en pause)
     ========================================================= */
  function redrawSpectrumNow(){
    const inp = readInputs();
    if(!inp){
      // pas d‚Äôinputs valides : on dessine un spectre ‚Äúvide‚Äù
      drawSpectrum(0, 0, specTime);
      return;
    }

    const geo = validateGeometryOpenBelt(inp);
    if(!geo.ok){
      // g√©om√©trie impossible : on garde spectre, mais avec valeurs calculables quand m√™me
      // (ici, on √©vite division par z√©ro)
      drawSpectrum(inp.rpm/60, 0, specTime);
      return;
    }

    const hzMotor = inp.rpm / 60;

    const Lmm = beltLengthOpenBeltMM(inp.d1mm, inp.d2mm, inp.ccmm);
    const vmm = beltLinearSpeed_mm_s(inp.d1mm, inp.rpm);
    const hzBelt = vmm / Lmm;

    drawSpectrum(hzMotor, hzBelt, specTime);
  }

  /* =========================================================
     DRAW (SC√àNE + OUTPUTS + SPECTRE)
     ========================================================= */
  function draw(){
    const dpr = dprNow();
    const W = canvas.width / dpr;
    const H = canvas.height / dpr;

    // fond
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    const inp = readInputs();
    if(!inp){
      infoEl.innerHTML = `<span class="bad">‚õî Entre RPM, √ò menante, √ò men√©e et C-C.</span>`;
      // sorties
      outLength.textContent = "‚Äî";
      outRPM1.textContent = outCPM1.textContent = outHZ1.textContent = "‚Äî";
      outRPM2.textContent = outCPM2.textContent = outHZ2.textContent = "‚Äî";
      outHZBelt.textContent = outFPM.textContent = outStrobe.textContent = "‚Äî";
      // spectre (statique)
      drawSpectrum(0,0,specTime);
      return;
    }

    // validation g√©om√©trie (message uniquement quand invalide)
    const geo = validateGeometryOpenBelt(inp);
    if(!geo.ok){
      infoEl.innerHTML = geo.html;

      // on stoppe l‚Äôanimation si c‚Äô√©tait en cours (√©vite bug)
      running = false;

      // on affiche quand m√™me les sorties ‚Äúde base‚Äù (sauf hzBelt)
      const hzMotor = inp.rpm/60;
      outRPM1.textContent = inp.rpm.toFixed(0);
      outCPM1.textContent = inp.rpm.toFixed(0);
      outHZ1.textContent  = hzMotor.toFixed(2);

      const rpmMenee = inp.rpm * (inp.d1mm / inp.d2mm);
      const hzMenee  = rpmMenee/60;
      outRPM2.textContent = rpmMenee.toFixed(0);
      outCPM2.textContent = rpmMenee.toFixed(0);
      outHZ2.textContent  = hzMenee.toFixed(2);

      outHZBelt.textContent = "‚Äî";
      outFPM.textContent    = "‚Äî";
      outStrobe.textContent = "‚Äî";
      outLength.textContent = "‚Äî";

      // spectre (moteur seulement)
      drawSpectrum(hzMotor, 0, specTime);
      return;
    }else{
      infoEl.innerHTML = ""; // PAS de message ‚Äúvalid√©‚Äù (comme tu voulais)
    }

    // ===== calculs longueur + vitesses =====
    const Lmm = beltLengthOpenBeltMM(inp.d1mm, inp.d2mm, inp.ccmm);

    const v_mm_s = beltLinearSpeed_mm_s(inp.d1mm, inp.rpm);
    const v_in_s = v_mm_s / IN_TO_MM;
    const v_ft_min = v_in_s * 5;

    const hzMotor = inp.rpm / 60;
    const hzBelt  = v_mm_s / Lmm;

    // stroboscope : flash/min = Hz√ó60
    const strobeFPM = hzBelt * 60;

    // longueur affich√©e
    const Ldisplay = (unitEl.value === "imperial")
      ? (Lmm / IN_TO_MM).toFixed(2) + " po"
      : Lmm.toFixed(1) + " mm";
    outLength.textContent = Ldisplay;

    // RPM/CPM/Hz menante
    outRPM1.textContent = inp.rpm.toFixed(0);
    outCPM1.textContent = inp.rpm.toFixed(0);
    outHZ1.textContent  = hzMotor.toFixed(2);

    // men√©e
    const rpmMenee = inp.rpm * (inp.d1mm / inp.d2mm);
    const hzMenee  = rpmMenee / 60;
    outRPM2.textContent = rpmMenee.toFixed(0);
    outCPM2.textContent = rpmMenee.toFixed(0);
    outHZ2.textContent  = hzMenee.toFixed(2);

    // courroie
    outHZBelt.textContent = hzBelt.toFixed(3);
    outFPM.textContent    = v_ft_min.toFixed(0);
    outStrobe.textContent = strobeFPM.toFixed(0);

    // ===== spectre =====
    // IMPORTANT: ‚Äúlive‚Äù uniquement si running, car specTime n‚Äôavance que si running
    drawSpectrum(hzMotor, hzBelt, specTime);

    // ===== dessin poulies + courroie =====
    const r1mm = inp.d1mm/2;
    const r2mm = inp.d2mm/2;
    const Cmm  = inp.ccmm;

    const margin = 26;
    const s = Math.min(
      (W - 2*margin) / (Cmm + r1mm + r2mm),
      (H - 2*margin) / (2 * Math.max(r1mm, r2mm))
    );

    const r1 = r1mm*s, r2 = r2mm*s, C = Cmm*s;

    const x1 = margin + r1;
    const x2 = x1 + C;
    const y  = H/2;

    const path = buildBeltPath(x1,y,r1, x2,y,r2);
    const pts  = path.pts;

    // courroie
    ctx.strokeStyle = "#9a9a9a";
    ctx.lineWidth = 4;
    ctx.lineCap="round";
    ctx.lineJoin="round";
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();

    // poulies
    drawPulley(x1, y, r1, "#00a2ff", ang1);
    drawPulley(x2, y, r2, "#ff9800", ang2);

    // point sur la courroie (se d√©place uniquement si running car t n‚Äôavance que si running)
    const w1 = TAU*(inp.rpm/60);
    const v_px_s = Math.abs(w1) * r1;
    const totalLen = polylineLength(pts);

    const sPos = (totalLen - (v_px_s * t) % totalLen) % totalLen;
    const P = pointAt(pts, sPos);

    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.arc(P.x,P.y,4,0,TAU);
    ctx.fill();
  }

  /* =========================================================
     LOOP (animation)
     ========================================================= */
  function loop(ts){
    if(lastTS === null) lastTS = ts;
    const dt = (ts - lastTS) / 1000;
    lastTS = ts;

    if(running){
      const slow = parseFloat(slowEl.value) || 1;

      // advance temps (uniquement si Play)
      t += dt / slow;
      specTime += dt; // spectre ‚Äúlive‚Äù UNIQUEMENT en Play

      // avance angles
      const rpm = parseFloat(rpmEl.value) || 0;
      const d1  = parseFloat(d1El.value)  || 1;
      const d2  = parseFloat(d2El.value)  || 1;

      const w1 = TAU * (rpm / 60);
      const w2 = w1 * (d1 / d2);

      ang1 += (w1 * dt) / slow;
      ang2 += (w2 * dt) / slow;
    }

    draw();
    requestAnimationFrame(loop);
  }

  /* =========================================================
     EVENTS UI
     ========================================================= */

  // Play : d√©marre SEULEMENT si inputs + g√©om√©trie OK
  playBtn.onclick = () => {
    const inp = readInputs();
    if(!inp){
      running = false;
      draw();
      return;
    }
    const geo = validateGeometryOpenBelt(inp);
    if(!geo.ok){
      running = false;
      draw();
      return;
    }
    running = true;
  };

  pauseBtn.onclick = () => { running = false; };

  resetBtn.onclick = () => {
    running = false;
    t = 0;
    specTime = 0;
    ang1 = 0;
    ang2 = 0;
    draw();
  };

  fsBtn.onclick = () => { toggleSpectrumFS(); };

  // changements inputs : on redraw tout (sans rendre ‚Äúlive‚Äù)
  [rpmEl,d1El,d2El,ccEl,unitEl,slowEl,faultEl].forEach(el=>{
    el.addEventListener("input", () => {
      // si on change des valeurs en plein Play, √ßa reste Play.
      // sinon, √ßa reste fig√© (specTime n‚Äôavance pas).
      draw();
    });
  });

  // plein √©cran: resize / orientation
  window.addEventListener("resize", () => { resize(); checkOrientation(); draw(); });
  window.addEventListener("orientationchange", () => { resize(); checkOrientation(); draw(); });
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", () => { resize(); checkOrientation(); draw(); });
  }

  /* =========================================================
     PAN SUR LE SPECTRE (drag)
     - Fonctionne en pause
     - Redraw imm√©diat sans ‚Äúlive‚Äù
     ========================================================= */
  specCanvas.addEventListener("pointerdown", e => {
    isPanning = true;
    panStartX = e.clientX;
    panStartMin = spectrumView.minHz;
    try{ specCanvas.setPointerCapture(e.pointerId); }catch(_){}
  });

  specCanvas.addEventListener("pointermove", e => {
    if(!isPanning) return;

    const dxPx = e.clientX - panStartX;
    const widthPx = specCanvas.clientWidth || 1;
    const hzPerPx = spectrumView.spanHz / widthPx;

    let newMin = panStartMin - dxPx * hzPerPx;
    newMin = Math.max(0, Math.min(spectrumView.maxHz - spectrumView.spanHz, newMin));
    spectrumView.minHz = newMin;

    // redraw imm√©diat (specTime fig√© si pause)
    redrawSpectrumNow();
  });

  specCanvas.addEventListener("pointerup", e => {
    isPanning = false;
    try{ specCanvas.releasePointerCapture(e.pointerId); }catch(_){}
  });

  specCanvas.addEventListener("pointercancel", () => { isPanning = false; });

  /* =========================================================
     INIT (IMPORTANT : sinon fullscreen/premier draw bug)
     ========================================================= */
  resize();
  draw();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>