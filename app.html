<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />


<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Vibration">
<title>Simulateur analyse de vibration</title>
<style>
  /* ========================================================= */
/* ===================== BASE ============================== */
/* ========================================================= */

:root{
  --bg:#0b1436;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.7);
  --btn:#1c2b6a;
  --bad:#ff4d4d;
}

*{
  box-sizing:border-box;
  -webkit-tap-highlight-color:transparent;
}

body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial, system-ui, sans-serif;
  overflow-x:hidden;
}

body.modal-open{
  overflow:hidden;
}

/* ========================================================= */
/* ===================== HEADER ============================ */
/* ========================================================= */

header{
  padding:12px 18px;
  font-size:18px;
  font-weight:700;
  display:flex;
  justify-content:space-between;
  align-items:center;
}

/* ========================================================= */
/* ===================== CONTROLS ========================== */
/* ========================================================= */

/* ===== MOBILE (par d√©faut : 1 colonne) ===== */
.controls{
  padding:16px;
  display:grid;
  grid-template-columns:1fr;
  gap:14px;
}

.controls label{
  display:flex;
  flex-direction:column;
  font-size:14px;
  color:var(--muted);
}

.controls input,
.controls select{
  width:100%;
  min-height:40px;
  padding:8px 10px;
  font-size:15px;
  border-radius:10px;
  border:none;
}

/* ===== PC UNIQUEMENT ===== */
@media (min-width:1024px){

  .controls{
    max-width:1200px;
    margin:0 auto;
    padding:18px;

    display:grid;
    grid-template-columns: 1fr 1fr;
    column-gap:32px;
    row-gap:16px;
  }

  /* Chaque label occupe UNE cellule */
  .controls > label{
    width:100%;
  }

  /* Ligne logique (Entraxe + D√©fauts) */
  .controls-row{
    grid-column:1 / -1;
    display:grid;
    grid-template-columns: 1fr 1fr;
    column-gap:32px;
  }

  /* R√©sultats pleine largeur */
  .outputBox{
    grid-column:1 / -1;
  }

  /* Slider pleine largeur */
  .slow-wrap{
    grid-column:1 / -1;
  }

  /* Largeur MAX contr√¥l√©e (FINI les champs g√©ants) */
  .controls input,
  .controls select{
    max-width:320px;
  }

  /* D√©fauts et r√©sultats peuvent prendre toute la largeur */
  #faultSelect,
  .outputBox{
    max-width:100%;
  }
}

/* ========================================================= */
/* ===================== OUTPUT ============================ */
/* ========================================================= */

.outputBox{
  background:rgba(255,255,255,0.08);
  border-radius:12px;
  padding:12px 14px;
  font-size:15px;
  line-height:1.5;
}

.outputBox b{
  color:#cfe2ff;
}

/* ========================================================= */
/* ===================== SLIDER ============================ */
/* ========================================================= */

.slow-wrap{
  position:relative;
  padding-top:18px;
}

.slow-label{
  position:absolute;
  top:0;
  left:50%;
  transform:translateX(-50%);
  font-size:13px;
  opacity:.8;
  pointer-events:none;
}

/* ========================================================= */
/* ===================== BUTTONS =========================== */
/* ========================================================= */

.buttons,
.spectrum-controls{
  display:flex;
  gap:12px;
  padding:12px 18px;
  flex-wrap:wrap;
}

.buttons button,
.spectrum-controls button{
  min-width:140px;
  padding:10px 18px;
  font-size:15px;
  border:none;
  border-radius:12px;
  background:var(--btn);
  color:white;
  cursor:pointer;
}

.buttons button:active,
.spectrum-controls button:active{
  transform:scale(0.97);
}

/* ========================================================= */
/* ===================== STAGES ============================ */
/* ========================================================= */

.visual-zone{
  max-width:1200px;
  margin:0 auto;
  padding:18px;
}

.pc-layout{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:32px;
}

.stage{
  padding:0;
}

canvas{
  width:100%;
  display:block;
  background:#000;
  border-radius:12px;
}

</style>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

</head>

<body>

<header class="app-header">
  <span class="title">üîÑ Simulateur analyse vibratoire</span>

  <div style="display:flex; gap:8px;">
    <button id="enterAppFS" class="info-btn" aria-label="Plein √©cran">‚õ∂</button>
    <button id="infoBtn" class="info-btn" aria-label="Informations">‚ÑπÔ∏è</button>
  </div>
</header>

<div class="controls">
  <label>RPM moteur <input id="rpm" type="number" inputmode="decimal" value="1500"></label>

  <label>Unit√©s(po/mm)
    <select id="unit">
      <option value="imperial" selected>po</option>
      <option value="metric">mm</option>
    </select>
  </label>

  <label>√ò menante <input id="d1" type="number" inputmode="decimal" value="4"></label>
  <label>√ò men√©e <input id="d2" type="number" inputmode="decimal" value="9"></label>

<div class="controls-row">
  <label>
    Entraxe des poulies (C-C)
    <input id="cc" type="number" inputmode="decimal" value="21">
  </label>
  <label>
    <b>D√©fauts simul√©s</b> (choix multiples)
    <select id="faultSelect" multiple size="1">
      <option value="all">Tout</option>
      <option value="powerline">Hydro-Qu√©bec (60 Hz)</option>
      <option value="unbalance">Balourd (1√ó)</option>
      <option value="misalign">D√©salignement</option>
      <option value="looseness">Jeu m√©canique</option>
      <option value="belt">D√©faut de courroie</option>
      <option value="slip">Glissement</option>
      <option value="bearing">Roulement</option>
      <option value="resonance">R√©sonance</option>
    </select>
  </label>
</div>
  <div class="outputBox full half-pc">
    <div><b>Menante</b> : <span id="out-rpm1">‚Äî</span> RPM | <span id="out-cpm1">‚Äî</span> CPM | <span id="out-hz1">‚Äî</span> Hz</div>
    <div><b>Men√©e</b> : <span id="out-rpm2">‚Äî</span> RPM | <span id="out-cpm2">‚Äî</span> CPM | <span id="out-hz2">‚Äî</span> Hz</div>
    <div><b>Courroie</b> : <span id="out-hzbelt">‚Äî</span> Hz | <span id="out-fpm">‚Äî</span> ft/min | <span id="out-strobe">‚Äî</span> FPM</div>
    <div><b>Longueur courroie</b> : <span id="out-length">‚Äî</span></div>
   
  </div>
   <div class="slow-wrap full">
  <span class="slow-label">Ralenti (plus grand = plus lent)</span>
  <input id="slow" type="range" min="1" max="20" value="8">
</div>
  </div>
</div>

<div class="buttons">
  <button id="play">Play</button>
  <button id="pause">Pause</button>
  <button id="reset">Reset</button>
  <button id="exportPDF">PDF</button>
</div>
<div class="spectrum-controls">
  <button id="enterSpectrumFS">üîç Plein √©cran spectre</button>
</div>

<div id="fsHUD">
  <div class="fs-info">
    Pan: glisser ‚Üî (Hz)<br>
    Play = spectre live
  </div>
  <button id="exitSpectrumFS">‚ùå Quitter</button>
</div>
<div class="visual-zone">
  <div class="pc-layout">
    <div class="stage" id="sceneStage">
      <canvas id="scene"></canvas>
    </div>

    <div class="stage" id="specStage">
      <canvas id="spectrum"></canvas>
    </div>
  </div>
</div>


<div class="results" id="info"></div>

<div id="rotateWarn" class="rotate-warning">
  üîÑ Tournez votre t√©l√©phone en mode paysage
  <span>Pour une meilleure lecture du spectre</span>
</div>


<div id="infoModal" class="infoModal" aria-hidden="true">

  <div class="infoCard" role="dialog" aria-modal="true" aria-labelledby="infoTitle">

    <div class="infoHead">
      <div class="infoTitle" id="infoTitle">‚ÑπÔ∏è Informations</div>

      <div class="infoActions">
        <select id="infoMenu">
          <option value="simu">Info simulateur</option>
          <option value="pruf">Info Pruftechnik</option>
        </select>

        <button type="button" id="printInfo" class="infoPrint">Imprimer</button>
        <button type="button" id="closeInfo" class="infoClose">Fermer</button>
      </div>
    </div>

    <div class="infoBody" id="infoBody">
      <div class="infoPage" id="page-simu">
        <!-- contenu simulateur -->
        <section class="infoSection">
        <h3> Objectif</h3>
      <p>Cette application sert √† comprendre <b>comment</b> une machine vibre et <b>pourquoi</b> certaines vibrations indiquent un d√©faut.</p>
        </section>
  
   <section class="infoSection">
      <h3>2Ô∏è‚É£ Unit√©s</h3>
      <p><b>RPM</b> = tours/minute. <b>Hz</b> = tours/seconde.</p>
      <code>Hz = RPM √∑ 60</code>
</section>
  
  <section class="infoSection">
      <h3>3Ô∏è‚É£ Le 1√ó (le plus important)</h3>
      <p><b>1√ó</b> correspond √† la vitesse de rotation.</p>
      <p>Exemple : 1500 RPM ‚Üí 1500 √∑ 60 = <b>25 Hz</b> ‚Üí donc <b>1√ó = 25 Hz</b>.</p>
</section>
  
  <section class="infoSection">
      <h3>4Ô∏è‚É£ Amplitude (combien √ßa vibre)</h3>
      <p>On regarde la hauteur des lignes dans le spectre. L‚Äôunit√© ici est <b>mm/s</b>.</p>
      <p>Plus le chiffre est grand ‚Üí plus c‚Äôest s√©rieux.</p>
</section>

   <section class="infoSection">
      <h3>5Ô∏è‚É£ Zones ISO (gravit√©)</h3>
      <div style="
  margin:16px 0;
  padding:14px 18px;
  background:rgba(255,255,255,0.08);
  border-left:4px solid #00a2ff;
  border-radius:8px;
">
  <b> Classe ISO utilis√©e dans ce simulateur</b><br><br>

  Ce simulateur utilise la norme <b>ISO 10816 ‚Äì Classe I</b>.<br><br>

  <b>Classe I</b> :
  <ul>
    <li>Petites machines</li>
    <li>Moteurs √©lectriques</li>
    <li>Puissance typiquement &lt; 15 kW</li>
    <li>Machines rigides, mont√©es sur socle</li>
  </ul>

  <b>Classe II</b> (non utilis√©e ici) :
  <ul>
    <li>Machines plus grosses</li>
    <li>Structures plus flexibles</li>
    <li>Seuils ISO plus permissifs</li>
  </ul>

  <b> Pour l‚Äôapprentissage, la Classe I est la plus r√©aliste et la plus s√©curitaire.</b>
</div>
  </section>

   <section class="infoSection">
      <p>Les zones ISO servent √† savoir si la vibration est acceptable :</p>
      <p>A = tr√®s bon ‚Ä¢ B = acceptable ‚Ä¢ C = probl√®me ‚Ä¢ D = critique</p>
      <table class="isoTable">
  <thead>
    <tr>
      <th>Zone ISO</th>
      <th>Couleur</th>
      <th>Amplitude RMS (mm/s)</th>
      <th>Interpr√©tation</th>
    </tr>
  </thead>
  <tbody>
    <tr class="isoA">
      <td>A</td>
      <td>Vert</td>
      <td>‚â§ 0,71</td>
      <td>√âtat excellent (machine neuve ou √©quilibr√©e)</td>
    </tr>
    <tr class="isoB">
      <td>B</td>
      <td>Bleu</td>
      <td>0,71 ‚Äì 1,8</td>
      <td>Acceptable en service continu</td>
    </tr>
    <tr class="isoC">
      <td>C</td>
      <td>Orange</td>
      <td>1,8 ‚Äì 4,5</td>
      <td>D√©faut pr√©sent ‚Äì intervention √† planifier</td>
    </tr>
    <tr class="isoD">
      <td>D</td>
      <td>Rouge</td>
      <td>> 4,5</td>
      <td>Critique ‚Äì arr√™t recommand√©</td>
    </tr>
  </tbody>
</table>
  </section>


  <section class="infoSection">
      <h3>6Ô∏è‚É£ Courroie</h3>
      <p>La courroie a sa propre fr√©quence. Elle peut cr√©er des pics diff√©rents du moteur.</p>

      <h3>7Ô∏è‚É£ Formules utilis√©es (simplifi√©es)</h3>
      <p><b>Vitesse de courroie</b> :</p>
      <code>Vitesse = œÄ √ó diam√®tre √ó RPM</code>
      <p><b>Fr√©quence courroie</b> :</p>
      <code>Hz courroie = vitesse √∑ longueur</code>

      <h3>8Ô∏è‚É£ D√©fauts (exemples)</h3>
      <p><b>Balourd</b> : pic fort √† 1√ó</p>
      <p><b>D√©salignement</b> : pic fort √† 2√ó</p>
      <p><b>Jeu m√©canique</b> : plusieurs harmoniques</p>

      <h3> M√©thode de lecture</h3>
      <p>1) Trouver 1√ó ‚Ä¢ 2) Voir harmoniques ‚Ä¢ 3) Lire amplitude ‚Ä¢ 4) V√©rifier ISO ‚Ä¢ 5) Associer un d√©faut</p>

   </section>

    <section class="infoSection">
      <h3> 9Ô∏è‚É£ Calcul de la longueur de la courroie</h3>

<p>Pour une transmission √† <b>courroie ouverte</b> (comme dans ce simulateur), on utilise une formule
qui permet <b>d‚Äôestimer</b> la longueur de la courroie.</p>

<p><b>Formule utilis√©e :</b></p>

<code>
Longueur ‚âà 2 √ó C + (œÄ / 2) √ó (D1 + D2) + ((D2 ‚àí D1)¬≤ / (4 √ó C))
</code>

<p><b>Signification des termes :</b></p>
<ul>
  <li><b>C</b> : distance centre-√†-centre entre les deux poulies</li>
  <li><b>D1</b> : diam√®tre de la poulie menante</li>
  <li><b>D2</b> : diam√®tre de la poulie men√©e</li>
  <li><b>œÄ (pi)</b> ‚âà 3,14</li>
</ul>

<p>Cette formule additionne :</p>
<ul>
  <li>les parties droites de la courroie</li>
  <li>les parties enroul√©es sur les poulies</li>
  <li>une correction si les diam√®tres sont diff√©rents</li>
</ul>

<p><b>Important :</b> la longueur obtenue est <b>th√©orique</b>.  
En pratique, on choisit toujours une courroie <b>standard</b> la plus proche.</p>

<hr>
</section>

    <section class="infoSection">
<h3> 1Ô∏è‚É£0Ô∏è‚É£ Influence de l‚Äôangle de la courroie</h3>

<p>La courroie <b>n‚Äôenveloppe pas compl√®tement</b> les poulies.</p>

<p>La portion de poulie r√©ellement touch√©e s‚Äôappelle :</p>

<p><b> l‚Äôangle d‚Äôenroulement</b></p>

<p><b>Pourquoi c‚Äôest important ?</b></p>
<ul>
  <li>Grand angle ‚Üí meilleure adh√©rence</li>
  <li>Petit angle ‚Üí plus de risque de glissement</li>
</ul>

<p><b>Exemples :</b></p>
<ul>
  <li>Poulies tr√®s rapproch√©es ‚Üí angle faible ‚Üí glissement possible</li>
  <li>Poulies √©loign√©es ‚Üí angle plus grand ‚Üí transmission plus stable</li>
</ul>

<p>Dans ce simulateur :</p>
<ul>
  <li>l‚Äôangle est calcul√© automatiquement</li>
  <li>il influence la trajectoire de la courroie</li>
  <li>il peut influencer les d√©fauts simul√©s</li>
</ul>

<hr>
</section>

   <section class="infoSection">
<h3> 1Ô∏è‚É£1Ô∏è‚É£ Longueur r√©elle vs longueur calcul√©e</h3>

<p>La formule suppose que la courroie roule sur le <b>diam√®tre ext√©rieur</b> des poulies.</p>

<p>En r√©alit√© :</p>
<ul>
  <li>la courroie s‚Äôenfonce l√©g√®rement dans la gorge</li>
  <li>le diam√®tre r√©el de contact est un peu plus petit</li>
</ul>

<p><b>Cons√©quences :</b></p>
<ul>
  <li>la longueur r√©elle est l√©g√®rement diff√©rente</li>
  <li>la vitesse r√©elle peut varier un peu</li>
</ul>

<p>En analyse vibratoire, ces √©carts sont :</p>
<ul>
  <li>normaux</li>
  <li>accept√©s</li>
  <li>pris en compte avec des tol√©rances</li>
</ul>

<hr>

</section>

 <section class="infoSection"> 
<h3>‚ö° 1Ô∏è‚É£2Ô∏è‚É£ Influence de la fr√©quence √©lectrique (Hydro-Qu√©bec)</h3>

<p>Au Qu√©bec, la fr√©quence √©lectrique est :</p>

<code>60 Hz</code>

<p>Cette fr√©quence peut appara√Ætre dans un spectre de vibration
<b>sans √™tre un d√©faut m√©canique</b>.</p>

<p>On peut voir :</p>
<ul>
  <li>60 Hz</li>
  <li>120 Hz (2 √ó 60)</li>
  <li>180 Hz (3 √ó 60)</li>
</ul>

<p><b>Sources possibles :</b></p>
<ul>
  <li>champ magn√©tique du moteur</li>
  <li>effets √©lectromagn√©tiques</li>
  <li>couplage moteur / structure</li>
</ul>

<p><b>‚ö†Ô∏è Erreur fr√©quente! :</b></p>

<p>Un pic √† 60 Hz n‚Äôest <b>PAS automatiquement</b> un d√©faut m√©canique.</p>

<p><b>R√®gle simple :</b></p>
<p><b> Si un pic est exactement √† 60 Hz ou un multiple, penser d‚Äôabord √† l‚Äô√©lectricit√©.</b></p>

<hr>
</section>


<section class="infoSection"> 
  
<h3> 1Ô∏è‚É£3Ô∏è‚É£ Ce que fait ce simulateur</h3>

<p>Ce simulateur sert √† :</p>
<ul>
  <li>comprendre les relations entre vitesses</li>
  <li>visualiser les pics typiques</li>
  <li>apprendre √† lire un spectre vibratoire</li>
</ul>

<p>Il ne remplace pas :</p>
<ul>
  <li>un vrai capteur</li>
  <li>une vraie machine</li>
  <li>une vraie analyse terrain</li>
</ul>

<p><b>Mais il est parfait pour apprendre sans risque.</b></p>
        
  </section>      
        
      </div>

      <div class="infoPage" id="page-pruf" style="display:none;">
        <!-- contenu Pruftechnik -->
        
        <h3> Pruftechnik ‚Äî Terminologie utilis√©e</h3>

<p>Le simulateur utilise volontairement les <b>m√™mes termes</b> que les analyseurs vibratoires
<b>Pruftechnik</b> afin de pr√©parer l‚Äô√©l√®ve au terrain.</p>

<h4>1Ô∏è‚É£ RMS (Root Mean Square)</h4>
<p>Valeur efficace de la vibration.</p>
<ul>
  <li>Repr√©sente l‚Äô<b>√©nergie r√©elle</b> de vibration</li>
  <li>C‚Äôest la valeur utilis√©e pour la <b>norme ISO</b></li>
</ul>

<p><b> Dans Pruftechnik :</b> affich√© comme <b>Velocity RMS (mm/s)</b></p>

<hr>

<h4>2Ô∏è‚É£ Velocity (Vitesse vibratoire)</h4>
<p>Indique la vitesse de d√©placement de la machine pendant la vibration.</p>

<ul>
  <li>Unit√© : <b>mm/s</b></li>
  <li>Tr√®s sensible aux d√©fauts m√©caniques globaux</li>
</ul>

<p><b> Dans Pruftechnik :</b> mode <b>Velocity</b></p>

<hr>

<h4>3Ô∏è‚É£ Peak (Pic)</h4>
<p>Valeur maximale instantan√©e d‚Äôun signal.</p>

<ul>
  <li>Plus sensible aux chocs</li>
  <li>Moins stable pour l‚Äô√©valuation ISO</li>
</ul>

<p><b> Diff√©rence importante :</b></p>
<ul>
  <li>ISO = RMS</li>
  <li>Chocs / impacts = Peak</li>
</ul>

<hr>

<h4>4Ô∏è‚É£ 1√ó, 2√ó, 3√ó (Ordres)</h4>
<p>Les <b>ordres</b> correspondent √† des multiples de la vitesse de rotation.</p>

<ul>
  <li>1√ó = vitesse de rotation</li>
  <li>2√ó = deux fois la vitesse</li>
  <li>3√ó = trois fois la vitesse</li>
</ul>

<p><b> Dans Pruftechnik :</b> affich√© sous forme de pics ordonn√©s</p>

<hr>

<h4>5Ô∏è‚É£ Spectrum (Spectre)</h4>
<p>Graphique qui montre les vibrations <b>par fr√©quence</b>.</p>

<ul>
  <li>Axe horizontal = Hz</li>
  <li>Axe vertical = amplitude (mm/s)</li>
</ul>

<p><b> Dans Pruftechnik :</b> √©cran principal d‚Äôanalyse</p>

<hr>

<h4>6Ô∏è‚É£ Time Waveform (Signal temporel)</h4>
<p>Repr√©sentation de la vibration dans le temps.</p>

<ul>
  <li>Permet de voir les chocs</li>
  <li>Tr√®s utile pour les roulements</li>
</ul>

<p><b> Non simul√© ici</b>, mais important √† conna√Ætre</p>

<hr>

<h4>7Ô∏è‚É£ FFT (Fast Fourier Transform)</h4>
<p>Transformation math√©matique qui convertit :</p>

<p><b>Temps ‚Üí Fr√©quence</b></p>

<p>Sans FFT, il serait impossible d‚Äôidentifier les d√©fauts.</p>

<p><b> Pruftechnik :</b> FFT automatique en arri√®re-plan</p>

<hr>

<h4>8Ô∏è‚É£ ISO 10816 / 20816</h4>
<p>Norme internationale pour juger la gravit√© vibratoire.</p>

<ul>
  <li>Bas√©e sur la vitesse RMS</li>
  <li>Classes A √† D</li>
</ul>

<p><b> Utilis√©e directement dans Pruftechnik</b></p>

<hr>

<h4>9Ô∏è‚É£ Alarmes (Alert / Danger)</h4>
<p>Seuils configurables pour avertir l‚Äôutilisateur.</p>

<ul>
  <li>Alert = intervention √† planifier</li>
  <li>Danger = arr√™t recommand√©</li>
</ul>

<p><b> Simul√© ici via les zones ISO</b></p>

<hr>

<h4>üîü Trending (Suivi dans le temps)</h4>
<p>Comparaison des mesures sur plusieurs jours ou semaines.</p>

<ul>
  <li>Permet de voir une d√©gradation</li>
  <li>Fondamental en maintenance pr√©dictive</li>
</ul>

<p><b> Non simul√© ici</b>, mais concept cl√© √† comprendre</p>
        
        
      </div>
    </div>

  </div>
</div>





<script>
(() => {
  "use strict";

  /* ===================== CONSTANTES ===================== */
  const TAU = Math.PI * 2;
  const IN_TO_MM = 25.4;

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const isNum = (x)=>Number.isFinite(x);
  const ISO_CLASS = "I"; // petites machines / moteurs < 15 kW
const ISO_ZONES = [
  { name:"A", label:"Tr√®s bon", max:0.71, col:"rgba(0,200,0,0.12)" },
  { name:"B", label:"Acceptable", max:1.8, col:"rgba(0,162,255,0.12)" },
  { name:"C", label:"Mauvais", max:4.5, col:"rgba(255,165,0,0.12)" },
  { name:"D", label:"Critique", max:Infinity, col:"rgba(255,77,77,0.12)" }
];
function isoVerdict(mm_s_rms){
  for(const z of ISO_ZONES){
    if(mm_s_rms <= z.max) return z;
  }
  return ISO_ZONES[ISO_ZONES.length-1];
}

  function dprNow(){ return Math.min(3, window.devicePixelRatio || 1); }

function isMobile(){
  return /iphone|ipad|android/i.test(navigator.userAgent);
}

function isPortrait(){
  return window.innerHeight > window.innerWidth;
}

  /* ===================== √âTAT ===================== */
  let running = false;
  // ===== ENREGISTREMENT (Peak Hold par √©l√©ment) =====
let peakRecord = {}; // { label: { hz, amp } }   amp en mm/s
let snapshotMode = false;

  // temps s√©par√©s, MAIS une seule boucle RAF
  let tMotion = 0; // courroie / poulies
  let tSpec   = 0; // spectre (avance uniquement si running)

  let ang1 = 0;
  let ang2 = 0;

  // largeur (pour √©viter que √ßa saute visuellement sur mobile)
  let lockedWidth = null;

  // fullscreen spectre
  let spectrumFS = false;

  /* ===================== DOM ===================== */
  const canvas     = document.getElementById("scene");
  const ctx        = canvas.getContext("2d");

  const specCanvas = document.getElementById("spectrum");
  const specCtx    = specCanvas.getContext("2d");

  const rpmEl   = document.getElementById("rpm");
  const d1El    = document.getElementById("d1");
  const d2El    = document.getElementById("d2");
  const ccEl    = document.getElementById("cc");
  const unitEl  = document.getElementById("unit");
  const slowEl  = document.getElementById("slow");
  

  const infoEl     = document.getElementById("info");
  const rotateWarn = document.getElementById("rotateWarn");

  const outLength  = document.getElementById("out-length");
  const outRPM1    = document.getElementById("out-rpm1");
  const outCPM1    = document.getElementById("out-cpm1");
  const outHZ1     = document.getElementById("out-hz1");
  const outRPM2    = document.getElementById("out-rpm2");
  const outCPM2    = document.getElementById("out-cpm2");
  const outHZ2     = document.getElementById("out-hz2");
  const outHZBelt  = document.getElementById("out-hzbelt");
  const outFPM     = document.getElementById("out-fpm");
  const outStrobe  = document.getElementById("out-strobe");
const btnEnterFS = document.getElementById("enterSpectrumFS");
const btnExitFS  = document.getElementById("exitSpectrumFS");
let fsHideTimer = null;

function showFSHUD(){
  const hud = document.getElementById("fsHUD");

  hud.classList.add("visible");

  clearTimeout(fsHideTimer);
  fsHideTimer = setTimeout(() => {
    hud.classList.remove("visible");
  }, 3000);
}

  function enableLongPressFS(){
  if(!isMobile()) return;

  let pressTimer = null;

  specCanvas.addEventListener("touchstart", () => {
    if(!spectrumFS) return;

    pressTimer = setTimeout(() => {
      showFSHUD();
    }, 2000);
  }, { passive:true });

  ["touchend","touchcancel","touchmove"].forEach(evt=>{
    specCanvas.addEventListener(evt, ()=>{
      clearTimeout(pressTimer);
      pressTimer = null;
    }, { passive:true });
  });
}
btnEnterFS.onclick = () => {
  if(spectrumFS) return;

  spectrumFS = true;
  specCanvas.classList.add("spectrum-only");
  document.body.classList.add("spectrum-mode");
  document.body.classList.add("app-fullscreen");
  btnEnterFS.style.display = "none";
  btnExitFS.style.display = "inline-block";

  rotateWarn.style.display = "none";

  resize();
  redrawSpectrumNow();

  if(!isMobile()) showFSHUD(); // PC seulement
};

btnExitFS.onclick = () => {
  spectrumFS = false;

  specCanvas.classList.remove("spectrum-only");
  document.body.classList.remove("spectrum-mode");
    document.body.classList.remove("app-fullscreen");
  rotateWarn.style.display = "none";

  btnExitFS.style.display = "none";
  btnEnterFS.style.display = "inline-block";

  resize();
  redrawSpectrumNow();
  document.getElementById("fsHUD").classList.remove("visible");
};
  const playBtn  = document.getElementById("play");
  const pauseBtn = document.getElementById("pause");
  const resetBtn = document.getElementById("reset");
  const pdfBtn = document.getElementById("exportPDF");
pdfBtn.addEventListener("click", exportPDF);

  

  /* ===================== VUE SPECTRE (PAN) ===================== */
  const spectrumView = { minHz:0, spanHz:50, maxHz:300 };

  let isPanning   = false;
  let panStartX   = 0;
  let panStartMin = 0;

  /* ===================== INPUTS / VALIDATION ===================== */
  function readInputs(){
    let rpm = parseFloat(rpmEl.value);
    let d1  = parseFloat(d1El.value);
    let d2  = parseFloat(d2El.value);
    let cc  = parseFloat(ccEl.value);

    if(!isNum(rpm) || !isNum(d1) || !isNum(d2) || !isNum(cc)) return null;
    if(rpm <= 0 || d1 <= 0 || d2 <= 0 || cc <= 0) return null;

    // conversion vers mm si imp√©rial
    if(unitEl.value === "imperial"){
      d1 *= IN_TO_MM; d2 *= IN_TO_MM; cc *= IN_TO_MM;
    }

    return { rpm, d1mm:d1, d2mm:d2, ccmm:cc };
  }

  function validateGeometryOpenBelt(inp){
    const r1 = inp.d1mm/2;
    const r2 = inp.d2mm/2;
    const minCC = Math.abs(r2 - r1); // condition math mini (open belt)

    if(inp.ccmm <= minCC){
      const minTxt = (unitEl.value === "imperial")
        ? (minCC / IN_TO_MM).toFixed(2) + " po"
        : minCC.toFixed(1) + " mm";

      return {
  ok:false,
  html: `
    <div class="bad">‚õî G√©om√©trie impossible (open belt)</div>
    <div>C-C doit √™tre <b>&gt; |R2 ‚àí R1|</b>.</div>
    <div class="small">Minimum = ${minTxt}</div>
  `
};
    }
    return { ok:true, html:"" };
  }

  /* ===================== CALCULS ===================== */
  function beltLengthOpenBeltMM(D1mm, D2mm, Cmm){
    // L = 2C + (œÄ/2)(D1 + D2) + (D2 ‚àí D1)^2/(4C)
    return 2*Cmm + (Math.PI/2)*(D1mm + D2mm) + ((D2mm - D1mm)**2)/(4*Cmm);
  }

  function beltLinearSpeed_mm_s(d1mm, rpm){
    // v = œÄ D (rpm/60)  -> mm/s si D en mm
    return Math.PI * d1mm * (rpm/60);
  }

  /* ===================== G√âOM√âTRIE COURROIE ===================== */
  function buildBeltPath(x1,y1,r1, x2,y2,r2){
    const C = Math.hypot(x2-x1, y2-y1);
    const R = Math.max(r1,r2);
    const r = Math.min(r1,r2);

    // open-belt : phi = acos((R-r)/C)
    const phi = Math.acos(clamp((R - r)/C, -1, 1));

    const aL_top =  phi;
    const aL_bot = -phi;
    const aR_top = Math.PI - phi;
    const aR_bot = Math.PI + phi;

    const Ltop = {x:x1 + r1*Math.cos(aL_top), y:y1 + r1*Math.sin(aL_top)};
    const Lbot = {x:x1 + r1*Math.cos(aL_bot), y:y1 + r1*Math.sin(aL_bot)};
    const Rtop = {x:x2 + r2*Math.cos(aR_top), y:y2 + r2*Math.sin(aR_top)};
    const Rbot = {x:x2 + r2*Math.cos(aR_bot), y:y2 + r2*Math.sin(aR_bot)};

    // sweeps (sens visuel coh√©rent)
    const sweepRight = -(TAU - 2*phi); // arc long
    const sweepLeft  = -(2*phi);       // arc court

    function arcPoints(cx,cy,rad, aStart, sweep){
      const absSweep = Math.abs(sweep);
      const steps = Math.max(22, Math.floor((absSweep * rad) / 9));
      const pts = [];
      for(let i=0;i<=steps;i++){
        const u = i/steps;
        const a = aStart + sweep*u;
        pts.push({x:cx + rad*Math.cos(a), y:cy + rad*Math.sin(a)});
      }
      return pts;
    }

    // boucle : Ltop -> Rtop -> arc droite -> Lbot -> arc gauche -> Ltop
    const clean = [];
    clean.push(Ltop, Rtop);

    const arcR = arcPoints(x2,y2,r2, aR_top, sweepRight);
    for(let i=1;i<arcR.length;i++) clean.push(arcR[i]); // finit sur Rbot

    clean.push(Lbot); // ligne Rbot -> Lbot

    const arcL = arcPoints(x1,y1,r1, aL_bot, sweepLeft);
    for(let i=1;i<arcL.length;i++) clean.push(arcL[i]); // finit sur Ltop

    return clean;
  }

  function polylineLength(pts){
    let L=0;
    for(let i=1;i<pts.length;i++){
      L += Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
    }
    return L;
  }

  function pointAt(pts, s){
    let acc = 0;
    for(let i=1;i<pts.length;i++){
      const a = pts[i-1], b = pts[i];
      const seg = Math.hypot(b.x-a.x, b.y-a.y);
      if(acc + seg >= s){
        const u = (s - acc)/seg;
        return { x: a.x + (b.x-a.x)*u, y: a.y + (b.y-a.y)*u };
      }
      acc += seg;
    }
    return pts[pts.length-1];
  }

  function drawPulley(cx, cy, r, col, angle){
    ctx.strokeStyle = col;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, TAU);
    ctx.stroke();

    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(cx + (r-6)*Math.cos(angle), cy + (r-6)*Math.sin(angle), 3, 0, TAU);
    ctx.fill();
  }
  function peaks_powerline(_fMotor, _fBelt, t){
  const base = 60; // Hydro-Qu√©bec
  return [
    { hz: base,     amp: 0.90 + 0.10*Math.sin(t),     col:"#00e5ff", label:"√âlec 60 Hz" },
    { hz: base*2,   amp: 0.60 + 0.08*Math.sin(t*1.4), col:"#00bcd4", label:"√âlec 120 Hz" },
    { hz: base*3,   amp: 0.45 + 0.06*Math.sin(t*1.9), col:"#26c6da", label:"√âlec 180 Hz" }
  ];
}

  /* ===================== SPECTRE (PICS) ===================== */
  // Table des d√©fauts: chaque entr√©e renvoie un tableau de pics
  function peaks_normal(fMotor, _fBelt, t){
    const a_base = 1.00 + 0.10*Math.sin(t);
    return [
      { hz:fMotor, amp:a_base, col:"#00a2ff", label:"1√ó moteur" },
      { hz:fMotor*2, amp:0.35 + 0.05*Math.sin(t*1.7), col:"#5fbfff", label:"2√ó moteur" }
    ];
  }

  function peaks_unbalance(fMotor, _fBelt, t){
    return [
      { hz:fMotor, amp:1.85 + 0.25*Math.sin(t), col:"#ff5555", label:"Balourd (1√ó)" },
      { hz:fMotor*2, amp:0.35 + 0.10*Math.sin(t*1.7), col:"#ff8888", label:"Harmonique (2√ó)" }
    ];
  }

  function peaks_misalign(fMotor, _fBelt, t){
    return [
      { hz:fMotor, amp:1.10 + 0.20*Math.sin(t*1.7), col:"#ff9800", label:"D√©salign. (1√ó)" },
      { hz:fMotor*2, amp:1.55 + 0.25*Math.sin(t), col:"#ff9800", label:"D√©salign. (2√ó)" },
      { hz:fMotor*3, amp:0.55 + 0.10*Math.sin(t*2.3), col:"#ffb74d", label:"3√ó (souvent)" }
    ];
  }

  function peaks_looseness(fMotor, _fBelt, t){
    return [
      { hz:fMotor*0.5, amp:0.65 + 0.15*Math.sin(t*0.9), col:"#ffd54f", label:"0.5√ó (jeu)" },
      { hz:fMotor,     amp:1.05 + 0.20*Math.sin(t),     col:"#ffd54f", label:"Jeu 1√ó" },
      { hz:fMotor*2,   amp:0.95 + 0.20*Math.sin(t*1.7), col:"#ffd54f", label:"Jeu 2√ó" },
      { hz:fMotor*3,   amp:0.80 + 0.20*Math.sin(t*2.3), col:"#ffd54f", label:"Jeu 3√ó" }
    ];
  }

  function peaks_belt(fMotor, fBelt, t){
    const fb = fBelt;
    return [
      { hz:fb,   amp:1.20 + 0.20*Math.sin(t),     col:"#ffffff", label:"Courroie (1√ó)" },
      { hz:fb*2, amp:0.65 + 0.15*Math.sin(t*1.7), col:"#bbbbbb", label:"Courroie (2√ó)" },
      { hz:Math.max(0, fb - fMotor), amp:0.35 + 0.10*Math.sin(t*1.7), col:"#e0e0e0", label:"SB (fb‚àí1√ó)" },
      { hz:fb + fMotor,              amp:0.35 + 0.10*Math.sin(t*2.3), col:"#e0e0e0", label:"SB (fb+1√ó)" }
    ];
  }

  function peaks_slip(_fMotor, fBelt, t){
    const slip = 0.92 + 0.08*Math.sin(t*1.5);
    return [
      { hz:fBelt*slip, amp:0.95 + 0.20*Math.sin(t*1.7), col:"#ffcc00", label:"Glissement (fb√óslip)" },
      { hz:fBelt,      amp:0.45 + 0.10*Math.sin(t*2.3), col:"#fff59d", label:"fb (r√©f.)" }
    ];
  }

  function peaks_bearing(fMotor, _fBelt, t){
    const bpfo = fMotor * 4.0;
    const bpfi = fMotor * 5.2;
    const bsf  = fMotor * 2.6;
    return [
      { hz:bpfo,   amp:0.70 + 0.25*Math.sin(t*2.3), col:"#c77dff", label:"Roulement (BPFO)" },
      { hz:bpfi,   amp:0.60 + 0.25*Math.sin(t*1.7), col:"#c77dff", label:"Roulement (BPFI)" },
      { hz:bsf,    amp:0.45 + 0.20*Math.sin(t),     col:"#d7a7ff", label:"Roulement (BSF)" },
      { hz:bpfo*2, amp:0.35 + 0.10*Math.sin(t),     col:"#b388ff", label:"BPFO√ó2" },
      { hz:bpfi*2, amp:0.30 + 0.10*Math.sin(t*1.7), col:"#b388ff", label:"BPFI√ó2" }
    ];
  }

  function peaks_resonance(fMotor, _fBelt, t){
    const fr = fMotor * 2.6;
    return [
      { hz:fr-0.8, amp:1.10 + 0.20*Math.sin(t),     col:"#ff1744", label:"R√©son. (fr‚àí)" },
      { hz:fr,     amp:2.20 + 0.35*Math.sin(t),     col:"#ff1744", label:"R√©son. (fr)" },
      { hz:fr+0.8, amp:1.00 + 0.20*Math.sin(t*1.7), col:"#ff1744", label:"R√©son. (fr+)" }
    ];
  }

  const FAULT_TABLE = {
    none      : (fM,fB,t)=>peaks_normal(fM,fB,t),
    unbalance : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_unbalance(fM,fB,t) ],
    misalign  : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_misalign(fM,fB,t) ],
    looseness : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_looseness(fM,fB,t) ],
    belt      : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_belt(fM,fB,t) ],
    slip      : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_slip(fM,fB,t) ],
    bearing   : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_bearing(fM,fB,t) ],
    resonance : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_resonance(fM,fB,t) ],
    all       : (fM,fB,t)=>[
      ...peaks_powerline(fM,fB,t),
      ...peaks_normal(fM,fB,t).slice(0,1),
      ...peaks_unbalance(fM,fB,t),
      ...peaks_misalign(fM,fB,t),
      ...peaks_looseness(fM,fB,t),
      ...peaks_belt(fM,fB,t),
      ...peaks_slip(fM,fB,t),
      ...peaks_bearing(fM,fB,t),
      ...peaks_resonance(fM,fB,t),
      { hz:fM*4, amp:0.35 + 0.10*Math.sin(t*1.7), col:"#90caf9", label:"4√ó moteur" },
      { hz:fM*6, amp:0.25 + 0.10*Math.sin(t*2.3), col:"#90caf9", label:"6√ó moteur" }
    ],
    powerline : (fM,fB,t)=>[
  ...peaks_normal(fM,fB,t).slice(0,1),
  ...peaks_powerline(fM,fB,t)
],
  };

  function buildPeaks(fMotor, fBelt, time){
  const selected = getSelectedFaults();

  // Aucun d√©faut s√©lectionn√© ‚Üí normal
  if(selected.length === 0){
    return peaks_normal(fMotor, fBelt, time);
  }

  let peaks = [];

  for(const key of selected){
    const fn = FAULT_TABLE[key];
    if(fn){
      peaks = peaks.concat(fn(fMotor, fBelt, time));
    }
  }

  return peaks;
}
  /* ===================== DESSIN SPECTRE ===================== */
  function drawSpectrum(hzMotor, hzBelt, time){
    const dpr = dprNow();
    const W = specCanvas.width / dpr;
    const H = specCanvas.height / dpr;

    const hzZoneHeight = 42;
    let hzZoneY = spectrumFS ? (H - hzZoneHeight - 80) : (H - hzZoneHeight - 10);
    hzZoneY = Math.max(80, hzZoneY);

    const gridTop    = 16;
    const gridBottom = hzZoneY - 10;
    const gridHeight = gridBottom - gridTop;

    const ampLabelWidth = 58;
    const plotLeft  = ampLabelWidth;
    const plotRight = W;
    const plotWidth = plotRight - plotLeft;

    // ===== AUTO-SCALE AMPLITUDE (OPTION 1) =====
const peaks = buildPeaks(hzMotor, hzBelt, time);
// ===== ENREGISTREMENT AUTO (uniquement quand Play) =====
if(running){
  for(const p of peaks){
    if(!Number.isFinite(p.hz)) continue;

    // EXACTEMENT le m√™me facteur que l‚Äôaffichage
    const ampMMs = (Number.isFinite(p.amp) ? p.amp : 0) * 5;

    // cl√© = label (donc "1√ó moteur", "Balourd (1√ó)", etc.)
    const key = (p.label || "").trim();
    if(!key) continue;

    // garde le max
    if(!peakRecord[key] || ampMMs > peakRecord[key].amp){
      peakRecord[key] = { hz: p.hz, amp: ampMMs };
    }
  }
}
// amplitude max r√©elle (en mm/s p√©dagogiques)
let maxAmp = 1;
for(const p of peaks){
  const ampMMs = p.amp * 5;   // m√™me facteur que tes barres
  if(ampMMs > maxAmp) maxAmp = ampMMs;
}

// marge p√©dagogique + arrondi propre
const AMP_MAX  = Math.max(2, Math.ceil(maxAmp * 1.15));
const AMP_STEP = AMP_MAX <= 6 ? 1 : 2;
    const minHz = spectrumView.minHz;
    const maxHz = minHz + spectrumView.spanHz;
    const scaleX = plotWidth / (maxHz - minHz);

    specCtx.clearRect(0,0,W,H);
    specCtx.fillStyle = "#05080f";
    specCtx.fillRect(0,0,W,H);

    // bande Hz
    specCtx.fillStyle = "rgba(0,162,255,0.15)";
    specCtx.fillRect(0, hzZoneY, W, hzZoneHeight);

// ===== BANDES ISO (derri√®re les barres) =====
// mapping mm/s -> Y
const yFromAmp = (amp) => gridBottom - (amp / AMP_MAX) * gridHeight;

// on dessine A, B, C, D en bandes horizontales
let prev = 0;
for(const z of ISO_ZONES){
  const topAmp = Math.min(z.max, AMP_MAX);
  const yTop = yFromAmp(topAmp);
  const yBot = yFromAmp(prev);

  // si la bande d√©passe l'√©chelle actuelle, on coupe
  const y1 = Math.max(gridTop, Math.min(gridBottom, yTop));
  const y2 = Math.max(gridTop, Math.min(gridBottom, yBot));
  const hBand = Math.abs(y2 - y1);

  if(hBand > 0.5){
    specCtx.fillStyle = z.col;
    specCtx.fillRect(plotLeft, Math.min(y1,y2), (plotRight - plotLeft), hBand);

    // petit label de zone √† gauche
    specCtx.fillStyle = "rgba(234,241,255,0.85)";
    specCtx.font = "11px Arial";
    specCtx.textAlign = "left";
    specCtx.textBaseline = "middle";
    specCtx.fillText(
  `ISO ${ISO_CLASS} ${z.name} (${z.label})`,
  plotLeft + 6,
  Math.min(y1,y2) + 12
);
  }

  prev = z.max;
}

    // r√®gle Hz
    specCtx.strokeStyle = "rgba(255,255,255,0.35)";
    specCtx.fillStyle   = "#eaf1ff";
    specCtx.font        = "11px Arial";
    specCtx.textAlign   = "center";
    specCtx.textBaseline= "top";

    const majorStep = 10;
    const minorStep = 5;

    for(let hz = Math.ceil(minHz / minorStep) * minorStep; hz <= maxHz; hz += minorStep){
      const x = plotLeft + (hz - minHz) * scaleX;
      const isMajor = (hz % majorStep === 0);

      specCtx.beginPath();
      specCtx.moveTo(x, hzZoneY);
      specCtx.lineTo(x, hzZoneY + (isMajor ? 12 : 6));
      specCtx.stroke();

      if(isMajor){
        specCtx.fillText(hz + " Hz", x, hzZoneY + 14);
      }
    }

    // grille verticale
    specCtx.strokeStyle = "rgba(255,255,255,0.08)";
    for(let i=0;i<=8;i++){
      const x = plotLeft + i * plotWidth / 8;
      specCtx.beginPath();
      specCtx.moveTo(x, gridTop);
      specCtx.lineTo(x, gridBottom);
      specCtx.stroke();
    }

    // grille horizontale + labels mm/s
    specCtx.strokeStyle = "rgba(255,255,255,0.12)";
    specCtx.fillStyle   = "#cfd6ff";
    specCtx.font        = "11px Arial";
    specCtx.textAlign   = "right";
    specCtx.textBaseline= "middle";

    for(let a=0; a<=AMP_MAX; a+=AMP_STEP){
      const y = gridBottom - (a / AMP_MAX) * gridHeight;
      specCtx.beginPath();
      specCtx.moveTo(plotLeft, y);
      specCtx.lineTo(plotRight, y);
      specCtx.stroke();
      specCtx.fillText(a + " mm/s", plotLeft - 6, y);
    }

    
    

    // barres
    for(const p of peaks){
      if(!isNum(p.hz) || p.hz < minHz || p.hz > maxHz) continue;

      const x = plotLeft + (p.hz - minHz) * scaleX;

      const ampMMs = p.amp * 5; // facteur p√©dagogique
      const h = (ampMMs / AMP_MAX) * gridHeight;
      const yTop = gridBottom - h;

      specCtx.strokeStyle = p.col;
      specCtx.lineWidth = 3;
      specCtx.beginPath();
      specCtx.moveTo(x, gridBottom);
      specCtx.lineTo(x, yTop);
      specCtx.stroke();

      specCtx.fillStyle = "#cfd6ff";
      specCtx.font = "12px Arial";
      specCtx.textAlign = "center";
      specCtx.textBaseline = "bottom";
      specCtx.fillText(p.label, x, Math.max(yTop - 6, gridTop + 14));
    }
// ===== VERDICT ISO bas√© sur le pic max (dans la fen√™tre affich√©e) =====
let maxShown = 0;
for(const p of peaks){
  if(!Number.isFinite(p.hz)) continue;
  if(p.hz < minHz || p.hz > maxHz) continue;  // seulement ce qui est visible
  const ampMMs = (Number.isFinite(p.amp) ? p.amp : 0) * 5;
  if(ampMMs > maxShown) maxShown = ampMMs;
}

const z = isoVerdict(maxShown);

// bande de titre (en haut √† gauche)
specCtx.fillStyle = "rgba(0,0,0,0.35)";
specCtx.fillRect(plotLeft, 0, 270, 18);

specCtx.fillStyle = "#eaf1ff";
specCtx.font = "12px Arial";
specCtx.textAlign = "left";
specCtx.textBaseline = "middle";
specCtx.fillText(
  `ISO ${ISO_CLASS} : ${z.name} ‚Äî ${z.label} (max ${maxShown.toFixed(2)} mm/s)`,
  plotLeft + 6,
  9
);
    // axe
    specCtx.fillStyle = "#9aa5d6";
    specCtx.font = "12px Arial";
    specCtx.textAlign = "right";
    specCtx.textBaseline = "top";
    specCtx.fillText("Hz ‚Üí", W - 6, 6);
  }

function getSelectedFaults(){
  const sel = document.getElementById("faultSelect");
  const values = Array.from(sel.selectedOptions).map(o => o.value);

  // üü¢ Si "Tout" est s√©lectionn√© ‚Üí moteur en mode ALL
  if(values.includes("all")){
    return ["all"];
  }

  return values;
}
function renderPeakList(){
  const keys = Object.keys(peakRecord);

  if(keys.length === 0){
    infoEl.innerHTML = "<div class='small'>üì∏ Aucun pic enregistr√© (appuie Play).</div>";
    return;
  }

  // tri par amplitude d√©croissante
  keys.sort((a,b) => peakRecord[b].amp - peakRecord[a].amp);

  let html = "<b>üì∏ Photo instantan√©e ‚Äî pics max enregistr√©s</b><br><br>";
// verdict global ISO bas√© sur le plus gros pic enregistr√©
let maxRec = 0;
for(const k of keys){
  if(peakRecord[k].amp > maxRec) maxRec = peakRecord[k].amp;
}
const z = isoVerdict(maxRec);
html += `
  <div style="margin-bottom:12px;">
    <b>ISO ${ISO_CLASS}</b> : ${z.name} ‚Äî ${z.label}
    (max ${maxRec.toFixed(2)} mm/s)
  </div>
`;
  for(const label of keys){
    const p = peakRecord[label];
    html += `
  <div style="margin-bottom:10px;">
    ‚Ä¢ <b>${label}</b><br>
    &nbsp;&nbsp;${p.hz.toFixed(2)} Hz ‚Äî ${p.amp.toFixed(2)} mm/s
  </div>
`;
  }

  infoEl.innerHTML = html;
}

function updateSpectrumModeByOrientation(){

  // üî¥ Si PAS en plein √©cran spectre ‚Üí JAMAIS de message
  if(!spectrumFS){
    rotateWarn.style.display = "none";
    return;
  }

  // üíª PC ‚Üí JAMAIS de message
  if(!isMobile()){
    rotateWarn.style.display = "none";
    return;
  }

  // üì± Mobile
  const isLandscape = window.innerWidth > window.innerHeight;

  if(isLandscape){
    // ‚úÖ OK ‚Üí on enl√®ve le message
    rotateWarn.style.display = "none";

    // recalcul propre
    setTimeout(() => {
      resize();
      redrawSpectrumNow();
    }, 120);

    showFSHUD();
}else{
  // üì± PORTRAIT + FULLSCREEN ‚Üí MODE S√âCURIS√â
  rotateWarn.style.display = "flex";

  const hud = document.getElementById("fsHUD");

  // üîí HUD FORC√â VISIBLE
  hud.classList.add("visible");
  hud.style.pointerEvents = "auto";

  // ‚õî INTERDIT DE LE CACHER
  clearTimeout(fsHideTimer);
  fsHideTimer = null;
}
}
  /* ===================== RESIZE ===================== */
  function resize(){
  const dpr = dprNow();

  /* ========= ANIMATION ========= */
  const maxW = Math.min(window.innerWidth - 24, 720);
  if(!lockedWidth) lockedWidth = maxW;
  lockedWidth = Math.min(lockedWidth, maxW);

  const w = lockedWidth;
  const h = w * 0.55;

  canvas.style.width  = w + "px";
  canvas.style.height = h + "px";
  canvas.width  = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  /* ========= SPECTRE ========= */
  let specW, specH;

  if(spectrumFS){
    // üî¥ FULLSCREEN
    specW = window.innerWidth;
    specH = window.innerHeight;

    specCanvas.style.position = "fixed";
    specCanvas.style.left = "0";
    specCanvas.style.top  = "0";
    specCanvas.style.margin = "0";
    specCanvas.style.borderRadius = "0";
    specCanvas.style.zIndex = "9999";
  }else{
   specW = w;
specH = h;


    specCanvas.style.position = "relative";
    specCanvas.style.marginTop = "0";
    specCanvas.style.borderRadius = "12px";
    specCanvas.style.zIndex = "auto";
  }

  specCanvas.style.width  = specW + "px";
  specCanvas.style.height = specH + "px";
  specCanvas.width  = Math.round(specW * dpr);
  specCanvas.height = Math.round(specH * dpr);

  specCtx.setTransform(dpr,0,0,dpr,0,0);
  specCtx.imageSmoothingEnabled = false;
}
  /* ===================== FULLSCREEN / ORIENTATION ===================== */
  
  

  /* ===================== REDRAW SPECTRE (pause ok) ===================== */
  function redrawSpectrumNow(){
    const inp = readInputs();
    if(!inp){
      drawSpectrum(0, 0, tSpec);
      return;
    }

    const geo = validateGeometryOpenBelt(inp);
    const hzMotor = inp.rpm/60;

    if(!geo.ok){
      drawSpectrum(hzMotor, 0, tSpec);
      return;
    }

    const Lmm  = beltLengthOpenBeltMM(inp.d1mm, inp.d2mm, inp.ccmm);
    const vmm  = beltLinearSpeed_mm_s(inp.d1mm, inp.rpm);
    const hzBelt = (Lmm > 0) ? (vmm / Lmm) : 0;

    drawSpectrum(hzMotor, hzBelt, tSpec);
  }

  /* ===================== DRAW GLOBAL ===================== */
  function draw(){
    const dpr = dprNow();
    const W = canvas.width / dpr;
    const H = canvas.height / dpr;

    // fond sc√®ne
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    const inp = readInputs();
    if(!inp){
      infoEl.innerHTML = `<span class="bad">‚õî Entre RPM, √ò menante, √ò men√©e et C-C.</span>`;
      outLength.textContent = "‚Äî";
      outRPM1.textContent = outCPM1.textContent = outHZ1.textContent = "‚Äî";
      outRPM2.textContent = outCPM2.textContent = outHZ2.textContent = "‚Äî";
      outHZBelt.textContent = outFPM.textContent = outStrobe.textContent = "‚Äî";
      drawSpectrum(0,0,tSpec);
      return;
    }

    const geo = validateGeometryOpenBelt(inp);
    if(!geo.ok){
      infoEl.innerHTML = geo.html;

      // stop play (√©vite ‚Äúangles qui partent en NaN‚Äù dans certaines configs)
      running = false;

      const hzMotor = inp.rpm/60;

      outRPM1.textContent = inp.rpm.toFixed(0);
      outCPM1.textContent = inp.rpm.toFixed(0);
      outHZ1.textContent  = hzMotor.toFixed(2);

      const rpmMenee = inp.rpm * (inp.d1mm / inp.d2mm);
      const hzMenee  = rpmMenee/60;
      outRPM2.textContent = rpmMenee.toFixed(0);
      outCPM2.textContent = rpmMenee.toFixed(0);
      outHZ2.textContent  = hzMenee.toFixed(2);

      outHZBelt.textContent = "‚Äî";
      outFPM.textContent    = "‚Äî";
      outStrobe.textContent = "‚Äî";
      outLength.textContent = "‚Äî";

      drawSpectrum(hzMotor, 0, tSpec);
      return;
    }else{
      if(!snapshotMode){
  infoEl.innerHTML = "";
}
    }

    // calculs
    const Lmm = beltLengthOpenBeltMM(inp.d1mm, inp.d2mm, inp.ccmm);
    const v_mm_s   = beltLinearSpeed_mm_s(inp.d1mm, inp.rpm);
    const v_in_s   = v_mm_s / IN_TO_MM;
    const v_ft_min = v_in_s * 5;

    const hzMotor = inp.rpm / 60;
    const hzBelt  = (Lmm > 0) ? (v_mm_s / Lmm) : 0;

    const strobeFPM = hzBelt * 60;

    // outputs
    outLength.textContent = (unitEl.value === "imperial")
      ? (Lmm / IN_TO_MM).toFixed(2) + " po"
      : Lmm.toFixed(1) + " mm";

    outRPM1.textContent = inp.rpm.toFixed(0);
    outCPM1.textContent = inp.rpm.toFixed(0);
    outHZ1.textContent  = hzMotor.toFixed(2);

    const rpmMenee = inp.rpm * (inp.d1mm / inp.d2mm);
    const hzMenee  = rpmMenee / 60;
    outRPM2.textContent = rpmMenee.toFixed(0);
    outCPM2.textContent = rpmMenee.toFixed(0);
    outHZ2.textContent  = hzMenee.toFixed(2);

    outHZBelt.textContent = hzBelt.toFixed(3);
    outFPM.textContent    = v_ft_min.toFixed(0);
    outStrobe.textContent = strobeFPM.toFixed(0);

    // spectre (live uniquement si running car tSpec n‚Äôavance que si running)
    drawSpectrum(hzMotor, hzBelt, tSpec);

    // dessin sc√®ne courroie + poulies
    const r1mm = inp.d1mm/2;
    const r2mm = inp.d2mm/2;
    const Cmm  = inp.ccmm;

    const margin = 26;
    const s = Math.min(
      (W - 2*margin) / (Cmm + r1mm + r2mm),
      (H - 2*margin) / (2 * Math.max(r1mm, r2mm))
    );

    const r1 = r1mm*s, r2 = r2mm*s, C = Cmm*s;
    const x1 = margin + r1;
    const x2 = x1 + C;
    const y  = H/2;

    const pts = buildBeltPath(x1,y,r1, x2,y,r2);

    ctx.strokeStyle = "#9a9a9a";
    ctx.lineWidth = 4;
    ctx.lineCap="round";
    ctx.lineJoin="round";
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();

    drawPulley(x1, y, r1, "#00a2ff", ang1);
    drawPulley(x2, y, r2, "#ff9800", ang2);

    // point sur courroie
    const w1 = TAU*(inp.rpm/60);
    const v_px_s = Math.abs(w1) * r1;
    const totalLen = polylineLength(pts);
    const sPos = (totalLen - (v_px_s * tMotion) % totalLen) % totalLen;
    const P = pointAt(pts, sPos);

    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.arc(P.x,P.y,4,0,TAU);
    ctx.fill();
  }

  /* ===================== LOOP UNIQUE RAF ===================== */
  let lastTS = null;
  function loop(ts){
    if(lastTS === null) lastTS = ts;
    const dt = (ts - lastTS) / 1000;
    lastTS = ts;

    if(running){
      const slow = Math.max(1, parseFloat(slowEl.value) || 1);

      // avance temps (Play seulement)
      tMotion += dt / slow;
      tSpec   += dt;

      // angles: utilisent les valeurs converties (mm) pour ratio correct m√™me en imp√©rial
      const inp = readInputs();
      if(inp){
        const w1 = TAU * (inp.rpm / 60);
        const ratio = inp.d1mm / inp.d2mm;
        const w2 = w1 * ratio;
        ang1 += (w1 * dt) / slow;
        ang2 += (w2 * dt) / slow;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  /* ===================== EVENTS UI ===================== */

window.addEventListener("resize", () => {
  updateSpectrumModeByOrientation();
  draw();
});

window.addEventListener("orientationchange", () => {
  updateSpectrumModeByOrientation();
  draw();
});

if(window.visualViewport){
  window.visualViewport.addEventListener("resize", () => {
    updateSpectrumModeByOrientation();
    draw();
  });
}

playBtn.addEventListener("click", () => {

  snapshotMode = false;   // on quitte le mode photo
  peakRecord = {};        // on repart un nouvel enregistrement
  infoEl.innerHTML = "";  // nettoie l‚Äôaffichage

  const inp = readInputs();
  if(!inp){ running = false; draw(); return; }

  const geo = validateGeometryOpenBelt(inp);
  if(!geo.ok){ running = false; draw(); return; }

  running = true;         // üî¥ LIVE reprend
});
  pauseBtn.addEventListener("click", () => {
  running = false;
  snapshotMode = true;   // üîí verrou affichage
  renderPeakList();      // üì∏ affiche la fiche
});

  resetBtn.addEventListener("click", () => {
  running = false;
  tMotion = 0;
  tSpec   = 0;
  ang1 = 0;
  ang2 = 0;

  peakRecord = {};      // ‚úÖ efface la m√©moire
  infoEl.innerHTML = ""; // optionnel: efface l'affichage

  draw();
});
  
  

  // Inputs : redraw (spectre fig√© si pause)
  [rpmEl,d1El,d2El,ccEl,unitEl,slowEl].forEach(el=>{
    el.addEventListener("input", () => {
      // si la g√©om√©trie devient invalide en Play, draw() stoppera running
      draw();
    });
  });

  // Resize / orientation
  function handleViewportChange(){
    resize();
    
    
    draw();
  }
  
  /* ===================== PAN SPECTRE (pause ok) ===================== */
  specCanvas.addEventListener("pointerdown", e => {
    isPanning = true;
    panStartX = e.clientX;
    panStartMin = spectrumView.minHz;
    try{ specCanvas.setPointerCapture(e.pointerId); }catch(_){}
  });

  specCanvas.addEventListener("pointermove", e => {
    if(!isPanning) return;

    const dxPx = e.clientX - panStartX;
    const widthPx = specCanvas.clientWidth || 1;
    const hzPerPx = spectrumView.spanHz / widthPx;

    let newMin = panStartMin - dxPx * hzPerPx;
    newMin = Math.max(0, Math.min(spectrumView.maxHz - spectrumView.spanHz, newMin));
    spectrumView.minHz = newMin;

    // redraw imm√©diat (tSpec fig√© si pause)
    redrawSpectrumNow();
  });

  function endPan(e){
    isPanning = false;
    if(e && e.pointerId != null){
      try{ specCanvas.releasePointerCapture(e.pointerId); }catch(_){}
    }
  }
  specCanvas.addEventListener("pointerup", endPan);
  specCanvas.addEventListener("pointercancel", endPan);

  /* ===================== INIT ===================== */
  resize();
updateSpectrumModeByOrientation();
draw();
// ===== GESTION DU MENU D√âFAUTS (choix multiples + "Tout") =====
const faultSelect = document.getElementById("faultSelect");

if(faultSelect){
  faultSelect.addEventListener("change", () => {
    const values = Array.from(faultSelect.selectedOptions).map(o => o.value);

    // üü¢ Si "Tout" est s√©lectionn√© ‚Üí il √©crase les autres
    if(values.includes("all")){
      Array.from(faultSelect.options).forEach(opt => {
        opt.selected = (opt.value === "all");
      });
    }

    // üîÑ Mise √† jour imm√©diate du spectre
    redrawSpectrumNow();
  });
}

function exportPDF(){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  const keys = Object.keys(peakRecord);
  if(keys.length === 0){
    alert("Aucune donn√©e enregistr√©e.\n\nAppuie sur Play puis Pause.");
    return;
  }

  let y = 14;

  doc.setFont("helvetica","bold");
  doc.setFontSize(16);
  doc.text("Analyse vibratoire ‚Äî Photo instantan√©e", 14, y);
  y += 10;

  doc.setFontSize(11);
  doc.setFont("helvetica","normal");
  doc.text(`Date : ${new Date().toLocaleString()}`, 14, y);
  y += 10;

  doc.setFont("helvetica","bold");
  doc.text("R√©sultats mesur√©s :", 14, y);
  y += 8;

  const sorted = keys.sort((a,b)=>peakRecord[b].amp - peakRecord[a].amp);

  for(const label of sorted){
    const p = peakRecord[label];
    const iso = isoVerdict(p.amp);

    if(y > 270){
      doc.addPage();
      y = 14;
    }

    doc.setFont("helvetica","bold");
    doc.text(label, 14, y);

    doc.setFont("helvetica","normal");
    y += 6;
    doc.text(`Fr√©quence : ${p.hz.toFixed(2)} Hz`, 18, y);
    y += 6;
    doc.text(`Amplitude : ${p.amp.toFixed(2)} mm/s`, 18, y);
    y += 6;

    doc.setTextColor(0,0,0);
    doc.text(`Classe ISO : ${iso.label}`, 18, y);
    doc.setTextColor(0,0,0);

    y += 10;
  }

  doc.save("Analyse_vibratoire_ISO.pdf");
}
document.addEventListener("keydown", (e) => {
  if(e.key === "Escape" && spectrumFS){
    btnExitFS.click();
  }
});

if(window.visualViewport){
  window.visualViewport.addEventListener("resize", () => {
    updateSpectrumModeByOrientation();
  });
}
/* ===================== FULLSCREEN APP (PC) ===================== */

const btnAppFS = document.getElementById("enterAppFS");

if(btnAppFS){
  btnAppFS.addEventListener("click", async () => {

    // PC seulement
    if(window.innerWidth < 1024) return;

    try{
      if(!document.fullscreenElement){
        await document.documentElement.requestFullscreen();
        document.body.classList.add("app-fullscreen");
      }else{
        await document.exitFullscreen();
        document.body.classList.remove("app-fullscreen");
      }
    }catch(err){
      console.warn("Fullscreen refus√© :", err);
    }
  });
}

// s√©curit√© : si l‚Äôutilisateur sort avec ESC
document.addEventListener("fullscreenchange", () => {
  if(!document.fullscreenElement){
    document.body.classList.remove("app-fullscreen");
  }
});
enableLongPressFS();
specCanvas.addEventListener("mousemove", () => {
  if(spectrumFS && !isMobile()){
    showFSHUD();
  }
});
requestAnimationFrame(loop);


/* ================= INFO BULLE ================= */

const infoModal = document.getElementById("infoModal");
const closeInfo = document.getElementById("closeInfo");

function openInfo(){
  infoModal.classList.add("show");
  infoModal.setAttribute("aria-hidden","false");
  document.body.classList.add("modal-open"); // ‚úÖ BLOQUE LE BODY
}
closeInfo.addEventListener("click", () => {
  infoModal.classList.remove("show");
  infoModal.setAttribute("aria-hidden","true");
  document.body.classList.remove("modal-open");
});

const infoBtn = document.getElementById("infoBtn");

if(infoBtn){
  infoBtn.addEventListener("click", openInfo);
}


const printBtn = document.getElementById("printInfo");

if(printBtn){
  printBtn.addEventListener("click", () => {

    const content =
  (infoMenu.value === "simu")
    ? pageSimu.innerHTML
    : pagePruf.innerHTML;

    const printWindow = window.open("", "_blank");

    printWindow.document.write(`
      <!doctype html>
      <html lang="fr">
      <head>
        <meta charset="utf-8">
        <title>Guide p√©dagogique ‚Äì Analyse vibratoire</title>
        <style>
          body{
            font-family: Arial, system-ui, sans-serif;
            margin:30mm;
            line-height:1.6;
            color:#000;
          }
          h3{ margin-top:24px; }
          code{
            display:block;
            background:#f2f2f2;
            padding:8px 12px;
            border-radius:6px;
            white-space:nowrap;
          }
          ul,ol{ margin-left:20px; }
          hr{ margin:30px 0; }
         </style>
      </head>
      <body>
        <h1>Guide p√©dagogique ‚Äì Analyse vibratoire</h1>
        ${content}
      </body>
      </html>
    `);

    printWindow.document.close();
    printWindow.focus();
    printWindow.onload = () => {
  printWindow.print();
};
  });
}
const infoMenu = document.getElementById("infoMenu");
const pageSimu = document.getElementById("page-simu");
const pagePruf = document.getElementById("page-pruf");


if(infoMenu){
  infoMenu.addEventListener("change", () => {
    pageSimu.style.display = infoMenu.value === "simu" ? "block" : "none";
    pagePruf.style.display = infoMenu.value === "pruf" ? "block" : "none";
  });
}


/* ================= NUMPAD PC ================= */

/* ================= NUMPAD PC ================= */

let activeInput = null;

window.addEventListener("DOMContentLoaded", () => {

  const numPad = document.getElementById("numPad");
  if(!numPad) return; // s√©curit√© absolue

  document.addEventListener("focusin", (e) => {
    if(window.innerWidth < 1024) return;

    const el = e.target;
    if(el.tagName === "INPUT" && el.type === "number"){
      activeInput = el;
      numPad.classList.remove("hidden");
    }
  });

  document.addEventListener("focusout", (e) => {
    if(e.target === activeInput){
      setTimeout(()=>{ 
        if(!numPad.contains(document.activeElement)){
          numPad.classList.add("hidden");
          activeInput = null;
        }
      }, 150);
    }
  });

  numPad.addEventListener("click", (e) => {
    if(!activeInput) return;
    const btn = e.target.closest("button");
    if(!btn) return;

    const key = btn.dataset.key;
    const action = btn.dataset.action;

    if(key){
      activeInput.value += key;
      activeInput.dispatchEvent(new Event("input"));
    }

    if(action === "back"){
      activeInput.value = activeInput.value.slice(0,-1);
      activeInput.dispatchEvent(new Event("input"));
    }

    if(action === "clear"){
      activeInput.value = "";
      activeInput.dispatchEvent(new Event("input"));
    }

    if(action === "ok"){
      activeInput.blur();
      numPad.classList.add("hidden");
      activeInput = null;
    }
  });

});

})();
</script>




<!-- ICI : √âTAPE 1 -->
<div id="numPad" class="numpad hidden">
  <div class="numpad-grid">
    <button data-key="7">7</button>
    <button data-key="8">8</button>
    <button data-key="9">9</button>

    <button data-key="4">4</button>
    <button data-key="5">5</button>
    <button data-key="6">6</button>

    <button data-key="1">1</button>
    <button data-key="2">2</button>
    <button data-key="3">3</button>

    <button data-key="0" class="wide">0</button>
    <button data-key=".">.</button>
    <button data-action="back">‚Üê</button>

    <button data-action="clear" class="warn">C</button>
    <button data-action="ok" class="ok wide">OK</button>
  </div>
</div>

</body>
</html>
