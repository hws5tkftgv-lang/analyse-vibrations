<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Vibration">
<title>Courroie & poulies ‚Äî trajectoire correcte</title>
<style>
/* ===================== BASE ===================== */
html, body{
  height:100%;
}

:root{
  --bg:#0b1436;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.7);
  --btn:#1c2b6a;
  --bad:#ff4d4d;
}

*{
  box-sizing:border-box;
  -webkit-tap-highlight-color:transparent;
}

body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
  overflow-x:hidden;
  font-size:16px;
}

/* ===================== HEADER ===================== */
header{
  padding:10px 14px;
  font-size:16px;
  font-weight:700;
}

/* ===================== CONTROLS ===================== */
.controls{
  padding:10px 14px;
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:8px;
}

.controls label{
  font-size:12px;
  color:var(--muted);
}

.controls input,
.controls select{
  width:100%;
  padding:6px 8px;
  font-size:13px;
  border-radius:10px;
  border:none;
}

.controls .full{
  grid-column:1 / -1;
}

/* ===================== BUTTONS ===================== */
.buttons{
  display:flex;
  gap:10px;
  padding:0 14px 10px;
  flex-wrap:wrap;
}

button{
  flex:1;
  min-width:120px;
  padding:10px;
  font-size:15px;
  border:none;
  border-radius:12px;
  background:var(--btn);
  color:white;
  cursor:pointer;
}

button:active{
  transform:scale(0.98);
}

/* ===================== STAGES ===================== */
.stage{
  padding:10px 14px;
}

canvas{
  width:100%;
  display:block;
  background:#000;
  border-radius:12px;
}

#scene{
  background:#000;
}

#spectrum{
  background:#05080f;
  touch-action:none;
}

/* ===================== RESULTS ===================== */
.results{
  padding:10px 14px 18px;
  font-size:14px;
  line-height:1.45;
}

.bad{
  color:var(--bad);
  font-weight:700;
}

.small{
  font-size:12px;
  opacity:.75;
  margin-top:6px;
}

/* ===================== OUTPUT BOX ===================== */
.outputBox{
  background:linear-gradient(
    180deg,
    rgba(255,255,255,0.06),
    rgba(255,255,255,0.02)
  );
  border-radius:12px;
  padding:14px;
  font-size:14px;
  line-height:1.5;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
}
.outputBox span{
  font-weight:700;
}


.outputBox b{
  color:#cfe2ff;
}

/* ==================================================== */
/* ===================== FULLSCREEN ==================== */
/* ==================================================== */

/* Canvas fullscreen ONLY */
canvas.spectrum-only{
  position:fixed;
  inset:0;
  width:100dvw !important;
  height:100dvh !important;
  border-radius:0 !important;
  z-index:9999;
}

/* Mode spectre : cacher TOUT sauf spectre + HUD + warning */
body.spectrum-mode > *:not(#specStage):not(#fsHUD):not(#rotateWarn){
  display:none !important;
}

body.spectrum-mode{
  overflow:hidden;
}

body.spectrum-mode #specStage{
  padding:0 !important;
  margin:0 !important;
}

/* ===================== HUD FULLSCREEN ===================== */
/* ‚ö†Ô∏è HUD contr√¥l√© UNIQUEMENT par JS */
#fsHUD{
  position:fixed;
  top:12px;
  left:12px;
  z-index:10001;

  padding:10px 12px;
  border-radius:12px;
  background:rgba(0,0,0,0.35);
  color:#eaf1ff;
  font-size:12px;
  line-height:1.25;

  display:none;
  opacity:0;
  pointer-events:none;
  transition:opacity .3s ease;
}

#fsHUD.visible{
  display:flex;
  gap:12px;
  align-items:flex-start;
  opacity:1;
  pointer-events:auto;
}

#fsHUD .fs-info{
  pointer-events:none;
}

#exitSpectrumFS{
  background:#b71c1c;
  padding:8px 12px;
  border-radius:10px;
  font-size:13px;
  white-space:nowrap;
}

/* ===================== ROTATION WARNING ===================== */
.rotate-warning{
  position:fixed;
  inset:0;
  z-index:10000;
  background:rgba(5,8,15,0.85);

  display:none;
  align-items:center;
  justify-content:center;
  text-align:center;

  padding:24px;
  font-size:18px;
  font-weight:700;
  color:#eaf1ff;

  pointer-events:none;
}

.rotate-warning span{
  display:block;
  font-size:14px;
  font-weight:400;
  opacity:.85;
  margin-top:10px;
}

/* ===================== SPECTRUM CONTROLS ===================== */
.spectrum-controls{
  display:flex;
  gap:8px;
  padding:0 14px 10px;
}

.spectrum-controls button{
  padding:8px 12px;
  border-radius:8px;
  border:none;
  background:#1c2b5a;
  color:#eaf1ff;
  font-weight:600;
}

/* ================================================= */
/* ====== LAYOUT FINAL ‚Äî PC PROPRE ET LISIBLE ====== */
/* ================================================= */

@media (min-width: 900px){

  /* ================= INPUTS ================= */

  .controls{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:12px 16px;
    padding:10px 14px;
    max-width:1100px;
    margin:auto;
  }

  .controls label{
    font-size:14px;
    font-weight:600;
    color:#eaf1ff;
  }

  .controls input,
  .controls select{
    width:100%;
    margin-top:4px;
    padding:6px 8px;
    font-size:16px;
    background:#f2f4f8;
    color:#000;
    border-radius:6px;
    border:1px solid #cfd6e0;
  }

  /* ================= R√âSULTATS + D√âFAUT ================= */

  .results-row{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:18px;
    padding:10px 14px;
    max-width:1100px;
    margin:auto;
    align-items:start;
  }

  /* üîµ BLOC BLEU ‚Äî m√™mes dimensions que inputs */
  .blueBox{
    background:linear-gradient(
      180deg,
      rgba(255,255,255,0.06),
      rgba(255,255,255,0.02)
    );
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
    border-radius:12px;
    padding:12px 14px;
    font-size:15px;
    line-height:1.45;
  }

  .blueBox div{
    margin-bottom:4px;
  }

  .blueBox b{
    color:#cfe2ff;
  }

  /* ‚¨ú COLONNE DROITE ‚Äî d√©faut + ralenti */
  .faultBox{
    display:flex;
    flex-direction:column;
    gap:10px;
    padding:12px 14px;
    background:#ffffff;
    color:#000;
    border-radius:12px;
  }

  .faultBox label{
    font-size:14px;
    font-weight:600;
    color:#000;
  }

  .faultBox select,
  .faultBox input[type="range"]{
    width:100%;
  }

  .faultBox .small{
    font-size:13px;
    color:#333;
    margin-top:4px;
  }

}
</style>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>


</head>

<body>
<header>üîÑ Courroie & poulies ‚Äî trajectoire correcte (open belt)</header>


<!-- ================= CONTROLS ================= -->
<div class="pc-top-left">


<div class="controls">
  

  <label>
    RPM moteur
    <input id="rpm" type="number" value="1500">
  </label>

  <label>
    Unit√©s
    <select id="unit">
      <option value="imperial" selected>po</option>
      <option value="metric">mm</option>
    </select>
  </label>

  <label>
    √ò menante
    <input id="d1" type="number" value="4">
  </label>

  <label>
    √ò men√©e
    <input id="d2" type="number" value="9">
  </label>

  <label>
    C-C
    <input id="cc" type="number" value="21">
  </label>

</div>
</div>
<!-- ================= R√âSULTATS + D√âFAUT ================= -->
<div class="results-row">

  <!-- üîµ BLOC BLEU : r√©sultats (m√™me largeur que inputs) -->
  <div class="outputBox blueBox">

    <div>
      <b>Menante</b> :
      <span id="out-rpm1">‚Äî</span> RPM |
      <span id="out-cpm1">‚Äî</span> CPM |
      <span id="out-hz1">‚Äî</span> Hz
    </div>

    <div>
      <b>Men√©e</b> :
      <span id="out-rpm2">‚Äî</span> RPM |
      <span id="out-cpm2">‚Äî</span> CPM |
      <span id="out-hz2">‚Äî</span> Hz
    </div>

    <div>
      <b>Courroie</b> :
      <span id="out-hzbelt">‚Äî</span> Hz |
      <span id="out-fpm">‚Äî</span> ft/min |
      <span id="out-strobe">‚Äî</span> FPM
    </div>

    <div>
      <b>Longueur</b> :
      <span id="out-length">‚Äî</span>
    </div>

  </div>

  <!-- ‚¨ú COLONNE DROITE : d√©faut + ralenti -->
  <div class="faultBox">

    <label>
      D√©faut simul√©
      <select id="fault">
        <option value="none">Aucun (normal)</option>
        <option value="unbalance">Balourd (1√ó)</option>
        <option value="misalign">D√©salignement</option>
        <option value="looseness">Jeu m√©canique</option>
        <option value="belt">D√©faut de courroie</option>
        <option value="slip">Glissement</option>
        <option value="bearing">Roulement</option>
        <option value="resonance">R√©sonance</option>
        <option value="all">TOUT</option>
      </select>
    </label>

    <label class="small">
      Ralenti (plus grand = plus lent)
    </label>

    <input id="slow" type="range" min="1" max="20" value="8">

  </div>

</div>

<!-- ================= BOUTONS ================= -->
<div class="buttons">
  <button id="play">Play</button>
  <button id="pause">Pause</button>
  <button id="reset">Reset</button>
  <button id="exportPDF">PDF</button>
</div>

<!-- ================= SPECTRE ================= -->
<div class="spectrum-controls">
  <button id="enterSpectrumFS">üîç Plein √©cran spectre</button>
</div>

<div id="fsHUD">
  <div class="fs-info">
    Pan : glisser ‚Üî (Hz)<br>
    Play = spectre live
  </div>
  <button id="exitSpectrumFS">‚ùå Quitter</button>
</div>

<div class="stage" id="sceneStage">
  <canvas id="scene"></canvas>
</div>

<div class="stage" id="specStage">
  <canvas id="spectrum"></canvas>
</div>

<div class="results" id="info"></div>

<div id="rotateWarn" class="rotate-warning">
  üîÑ Tournez votre t√©l√©phone en mode paysage
  <span>Pour une meilleure lecture du spectre</span>
</div>



<script>
(() => {
  "use strict";
const FONT_BASE = 13;      // taille normale
const FONT_FS   = 16;      // plein √©cran
const FONT_MOB  = 15;      // mobile


  /* ===================== CONSTANTES ===================== */
  const TAU = Math.PI * 2;
  const IN_TO_MM = 25.4;

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const isNum = (x)=>Number.isFinite(x);
  // ===== ISO 20816 (ex ISO 10816) - Classe II (machines industrielles standard) =====
const ISO_CLASS = "II"; // affichage seulement

const ISO_ZONES = [
  { name:"A", label:"Bon",         max:1.12, col:"rgba(  0,200,  0,0.12)" },
  { name:"B", label:"Acceptable",  max:2.80, col:"rgba(  0,162,255,0.12)" },
  { name:"C", label:"Mauvais",     max:7.10, col:"rgba(255,165,  0,0.12)" },
  { name:"D", label:"Critique",    max:Infinity, col:"rgba(255, 77, 77,0.12)" }
];

function isoVerdict(mm_s_rms){
  for(const z of ISO_ZONES){
    if(mm_s_rms <= z.max) return z;
  }
  return ISO_ZONES[ISO_ZONES.length-1];
}

  function dprNow(){ return Math.min(3, window.devicePixelRatio || 1); }
function spectrumFont(px){
  specCtx.font = `${px}px Arial`;
}


function isMobile(){
  return /iphone|ipad|android/i.test(navigator.userAgent);
}

function isPortrait(){
  return window.innerHeight > window.innerWidth;
}


  /* ===================== √âTAT ===================== */
  let running = false;
  // ===== ENREGISTREMENT (Peak Hold par √©l√©ment) =====
let peakRecord = {}; // { label: { hz, amp } }   amp en mm/s
let snapshotMode = false;

  // temps s√©par√©s, MAIS une seule boucle RAF
  let tMotion = 0; // courroie / poulies
  let tSpec   = 0; // spectre (avance uniquement si running)

  let ang1 = 0;
  let ang2 = 0;

  // largeur (pour √©viter que √ßa saute visuellement sur mobile)
  let lockedWidth = null;

  // fullscreen spectre
  let spectrumFS = false;

  /* ===================== DOM ===================== */
  const canvas     = document.getElementById("scene");
  const ctx        = canvas.getContext("2d");

  const specCanvas = document.getElementById("spectrum");
  const specCtx    = specCanvas.getContext("2d");

  const rpmEl   = document.getElementById("rpm");
  const d1El    = document.getElementById("d1");
  const d2El    = document.getElementById("d2");
  const ccEl    = document.getElementById("cc");
  const unitEl  = document.getElementById("unit");
  const slowEl  = document.getElementById("slow");
  const faultEl = document.getElementById("fault");

  const infoEl     = document.getElementById("info");
  const rotateWarn = document.getElementById("rotateWarn");

  const outLength  = document.getElementById("out-length");
  const outRPM1    = document.getElementById("out-rpm1");
  const outCPM1    = document.getElementById("out-cpm1");
  const outHZ1     = document.getElementById("out-hz1");
  const outRPM2    = document.getElementById("out-rpm2");
  const outCPM2    = document.getElementById("out-cpm2");
  const outHZ2     = document.getElementById("out-hz2");
  const outHZBelt  = document.getElementById("out-hzbelt");
  const outFPM     = document.getElementById("out-fpm");
  const outStrobe  = document.getElementById("out-strobe");
const btnEnterFS = document.getElementById("enterSpectrumFS");
const btnExitFS  = document.getElementById("exitSpectrumFS");
let fsHideTimer = null;

function showFSHUD(){
  const hud = document.getElementById("fsHUD");

  hud.classList.add("visible");

  clearTimeout(fsHideTimer);
  fsHideTimer = setTimeout(() => {
    hud.classList.remove("visible");
  }, 3000);
}




  function enableLongPressFS(){
  if(!isMobile()) return;

  let pressTimer = null;

  specCanvas.addEventListener("touchstart", () => {
    if(!spectrumFS) return;

    pressTimer = setTimeout(() => {
      showFSHUD();
    }, 2000);
  }, { passive:true });

  ["touchend","touchcancel","touchmove"].forEach(evt=>{
    specCanvas.addEventListener(evt, ()=>{
      clearTimeout(pressTimer);
      pressTimer = null;
    }, { passive:true });
  });
}
btnEnterFS.onclick = () => {
  if(spectrumFS) return;

  spectrumFS = true;
  specCanvas.classList.add("spectrum-only");
  document.body.classList.add("spectrum-mode");

  btnEnterFS.style.display = "none";
  btnExitFS.style.display = "inline-block";

  rotateWarn.style.display = "none";

  resize();
  redrawSpectrumNow();

  if(!isMobile()) showFSHUD(); // PC seulement
};

btnExitFS.onclick = () => {
  spectrumFS = false;

  specCanvas.classList.remove("spectrum-only");
  document.body.classList.remove("spectrum-mode");
  rotateWarn.style.display = "none";

  btnExitFS.style.display = "none";
  btnEnterFS.style.display = "inline-block";

  resize();
  redrawSpectrumNow();
  document.getElementById("fsHUD").classList.remove("visible");
};
  const playBtn  = document.getElementById("play");
  const pauseBtn = document.getElementById("pause");
  const resetBtn = document.getElementById("reset");
  const pdfBtn = document.getElementById("exportPDF");
pdfBtn.addEventListener("click", exportPDF);

  

  /* ===================== VUE SPECTRE (PAN) ===================== */
  const spectrumView = { minHz:0, spanHz:50, maxHz:300 };

  let isPanning   = false;
  let panStartX   = 0;
  let panStartMin = 0;

  /* ===================== INPUTS / VALIDATION ===================== */
  function readInputs(){
    let rpm = parseFloat(rpmEl.value);
    let d1  = parseFloat(d1El.value);
    let d2  = parseFloat(d2El.value);
    let cc  = parseFloat(ccEl.value);

    if(!isNum(rpm) || !isNum(d1) || !isNum(d2) || !isNum(cc)) return null;
    if(rpm <= 0 || d1 <= 0 || d2 <= 0 || cc <= 0) return null;

    // conversion vers mm si imp√©rial
    if(unitEl.value === "imperial"){
      d1 *= IN_TO_MM; d2 *= IN_TO_MM; cc *= IN_TO_MM;
    }

    return { rpm, d1mm:d1, d2mm:d2, ccmm:cc };
  }

  function validateGeometryOpenBelt(inp){
    const r1 = inp.d1mm/2;
    const r2 = inp.d2mm/2;
    const minCC = Math.abs(r2 - r1); // condition math mini (open belt)

    if(inp.ccmm <= minCC){
      const minTxt = (unitEl.value === "imperial")
        ? (minCC / IN_TO_MM).toFixed(2) + " po"
        : minCC.toFixed(1) + " mm";

      return {
        ok:false,
        html: `
          <div class="bad">‚õî G√©om√©trie impossible (open belt)</div>
          <div>C-C doit √™tre <b>&gt; |R2 ‚àí R1|</b>.</div>
          <div class="small">Minimum = ${minTxt}</div>
        `
      };
    }
    return { ok:true, html:"" };
  }

  /* ===================== CALCULS ===================== */
  function beltLengthOpenBeltMM(D1mm, D2mm, Cmm){
    // L = 2C + (œÄ/2)(D1 + D2) + (D2 ‚àí D1)^2/(4C)
    return 2*Cmm + (Math.PI/2)*(D1mm + D2mm) + ((D2mm - D1mm)**2)/(4*Cmm);
  }

  function beltLinearSpeed_mm_s(d1mm, rpm){
    // v = œÄ D (rpm/60)  -> mm/s si D en mm
    return Math.PI * d1mm * (rpm/60);
  }

  /* ===================== G√âOM√âTRIE COURROIE ===================== */
  function buildBeltPath(x1,y1,r1, x2,y2,r2){
    const C = Math.hypot(x2-x1, y2-y1);
    const R = Math.max(r1,r2);
    const r = Math.min(r1,r2);

    // open-belt : phi = acos((R-r)/C)
    const phi = Math.acos(clamp((R - r)/C, -1, 1));

    const aL_top =  phi;
    const aL_bot = -phi;
    const aR_top = Math.PI - phi;
    const aR_bot = Math.PI + phi;

    const Ltop = {x:x1 + r1*Math.cos(aL_top), y:y1 + r1*Math.sin(aL_top)};
    const Lbot = {x:x1 + r1*Math.cos(aL_bot), y:y1 + r1*Math.sin(aL_bot)};
    const Rtop = {x:x2 + r2*Math.cos(aR_top), y:y2 + r2*Math.sin(aR_top)};
    const Rbot = {x:x2 + r2*Math.cos(aR_bot), y:y2 + r2*Math.sin(aR_bot)};

    // sweeps (sens visuel coh√©rent)
    const sweepRight = -(TAU - 2*phi); // arc long
    const sweepLeft  = -(2*phi);       // arc court

    function arcPoints(cx,cy,rad, aStart, sweep){
      const absSweep = Math.abs(sweep);
      const steps = Math.max(22, Math.floor((absSweep * rad) / 9));
      const pts = [];
      for(let i=0;i<=steps;i++){
        const u = i/steps;
        const a = aStart + sweep*u;
        pts.push({x:cx + rad*Math.cos(a), y:cy + rad*Math.sin(a)});
      }
      return pts;
    }

    // boucle : Ltop -> Rtop -> arc droite -> Lbot -> arc gauche -> Ltop
    const clean = [];
    clean.push(Ltop, Rtop);

    const arcR = arcPoints(x2,y2,r2, aR_top, sweepRight);
    for(let i=1;i<arcR.length;i++) clean.push(arcR[i]); // finit sur Rbot

    clean.push(Lbot); // ligne Rbot -> Lbot

    const arcL = arcPoints(x1,y1,r1, aL_bot, sweepLeft);
    for(let i=1;i<arcL.length;i++) clean.push(arcL[i]); // finit sur Ltop

    return clean;
  }

  function polylineLength(pts){
    let L=0;
    for(let i=1;i<pts.length;i++){
      L += Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
    }
    return L;
  }

  function pointAt(pts, s){
    let acc = 0;
    for(let i=1;i<pts.length;i++){
      const a = pts[i-1], b = pts[i];
      const seg = Math.hypot(b.x-a.x, b.y-a.y);
      if(acc + seg >= s){
        const u = (s - acc)/seg;
        return { x: a.x + (b.x-a.x)*u, y: a.y + (b.y-a.y)*u };
      }
      acc += seg;
    }
    return pts[pts.length-1];
  }

  function drawPulley(cx, cy, r, col, angle){
    ctx.strokeStyle = col;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, TAU);
    ctx.stroke();

    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(cx + (r-6)*Math.cos(angle), cy + (r-6)*Math.sin(angle), 3, 0, TAU);
    ctx.fill();
  }

  /* ===================== SPECTRE (PICS) ===================== */
  // Table des d√©fauts: chaque entr√©e renvoie un tableau de pics
  function peaks_normal(fMotor, _fBelt, t){
    const a_base = 1.00 + 0.10*Math.sin(t);
    return [
      { hz:fMotor, amp:a_base, col:"#00a2ff", label:"1√ó moteur" },
      { hz:fMotor*2, amp:0.35 + 0.05*Math.sin(t*1.7), col:"#5fbfff", label:"2√ó moteur" }
    ];
  }

  function peaks_unbalance(fMotor, _fBelt, t){
    return [
      { hz:fMotor, amp:1.85 + 0.25*Math.sin(t), col:"#ff5555", label:"Balourd (1√ó)" },
      { hz:fMotor*2, amp:0.35 + 0.10*Math.sin(t*1.7), col:"#ff8888", label:"Harmonique (2√ó)" }
    ];
  }

  function peaks_misalign(fMotor, _fBelt, t){
    return [
      { hz:fMotor, amp:1.10 + 0.20*Math.sin(t*1.7), col:"#ff9800", label:"D√©salign. (1√ó)" },
      { hz:fMotor*2, amp:1.55 + 0.25*Math.sin(t), col:"#ff9800", label:"D√©salign. (2√ó)" },
      { hz:fMotor*3, amp:0.55 + 0.10*Math.sin(t*2.3), col:"#ffb74d", label:"3√ó (souvent)" }
    ];
  }

  function peaks_looseness(fMotor, _fBelt, t){
    return [
      { hz:fMotor*0.5, amp:0.65 + 0.15*Math.sin(t*0.9), col:"#ffd54f", label:"0.5√ó (jeu)" },
      { hz:fMotor,     amp:1.05 + 0.20*Math.sin(t),     col:"#ffd54f", label:"Jeu 1√ó" },
      { hz:fMotor*2,   amp:0.95 + 0.20*Math.sin(t*1.7), col:"#ffd54f", label:"Jeu 2√ó" },
      { hz:fMotor*3,   amp:0.80 + 0.20*Math.sin(t*2.3), col:"#ffd54f", label:"Jeu 3√ó" }
    ];
  }

  function peaks_belt(fMotor, fBelt, t){
    const fb = fBelt;
    return [
      { hz:fb,   amp:1.20 + 0.20*Math.sin(t),     col:"#ffffff", label:"Courroie (1√ó)" },
      { hz:fb*2, amp:0.65 + 0.15*Math.sin(t*1.7), col:"#bbbbbb", label:"Courroie (2√ó)" },
      { hz:Math.max(0, fb - fMotor), amp:0.35 + 0.10*Math.sin(t*1.7), col:"#e0e0e0", label:"SB (fb‚àí1√ó)" },
      { hz:fb + fMotor,              amp:0.35 + 0.10*Math.sin(t*2.3), col:"#e0e0e0", label:"SB (fb+1√ó)" }
    ];
  }

  function peaks_slip(_fMotor, fBelt, t){
    const slip = 0.92 + 0.08*Math.sin(t*1.5);
    return [
      { hz:fBelt*slip, amp:0.95 + 0.20*Math.sin(t*1.7), col:"#ffcc00", label:"Glissement (fb√óslip)" },
      { hz:fBelt,      amp:0.45 + 0.10*Math.sin(t*2.3), col:"#fff59d", label:"fb (r√©f.)" }
    ];
  }

  function peaks_bearing(fMotor, _fBelt, t){
    const bpfo = fMotor * 4.0;
    const bpfi = fMotor * 5.2;
    const bsf  = fMotor * 2.6;
    return [
      { hz:bpfo,   amp:0.70 + 0.25*Math.sin(t*2.3), col:"#c77dff", label:"Roulement (BPFO)" },
      { hz:bpfi,   amp:0.60 + 0.25*Math.sin(t*1.7), col:"#c77dff", label:"Roulement (BPFI)" },
      { hz:bsf,    amp:0.45 + 0.20*Math.sin(t),     col:"#d7a7ff", label:"Roulement (BSF)" },
      { hz:bpfo*2, amp:0.35 + 0.10*Math.sin(t),     col:"#b388ff", label:"BPFO√ó2" },
      { hz:bpfi*2, amp:0.30 + 0.10*Math.sin(t*1.7), col:"#b388ff", label:"BPFI√ó2" }
    ];
  }

  function peaks_resonance(fMotor, _fBelt, t){
    const fr = fMotor * 2.6;
    return [
      { hz:fr-0.8, amp:1.10 + 0.20*Math.sin(t),     col:"#ff1744", label:"R√©son. (fr‚àí)" },
      { hz:fr,     amp:2.20 + 0.35*Math.sin(t),     col:"#ff1744", label:"R√©son. (fr)" },
      { hz:fr+0.8, amp:1.00 + 0.20*Math.sin(t*1.7), col:"#ff1744", label:"R√©son. (fr+)" }
    ];
  }

  const FAULT_TABLE = {
    none      : (fM,fB,t)=>peaks_normal(fM,fB,t),
    unbalance : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_unbalance(fM,fB,t) ],
    misalign  : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_misalign(fM,fB,t) ],
    looseness : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_looseness(fM,fB,t) ],
    belt      : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_belt(fM,fB,t) ],
    slip      : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_slip(fM,fB,t) ],
    bearing   : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_bearing(fM,fB,t) ],
    resonance : (fM,fB,t)=>[ ...peaks_normal(fM,fB,t).slice(0,1), ...peaks_resonance(fM,fB,t) ],
    all       : (fM,fB,t)=>[
      ...peaks_normal(fM,fB,t).slice(0,1),
      ...peaks_unbalance(fM,fB,t),
      ...peaks_misalign(fM,fB,t),
      ...peaks_looseness(fM,fB,t),
      ...peaks_belt(fM,fB,t),
      ...peaks_slip(fM,fB,t),
      ...peaks_bearing(fM,fB,t),
      ...peaks_resonance(fM,fB,t),
      { hz:fM*4, amp:0.35 + 0.10*Math.sin(t*1.7), col:"#90caf9", label:"4√ó moteur" },
      { hz:fM*6, amp:0.25 + 0.10*Math.sin(t*2.3), col:"#90caf9", label:"6√ó moteur" }
    ]
  };

  function buildPeaks(fMotor, fBelt, time, fault){
    const fn = FAULT_TABLE[fault] || FAULT_TABLE.none;
    const raw = fn(fMotor, fBelt, time);

    // Nettoyage + clamp
    const out = [];
    for(const p of raw){
      if(!p) continue;
      if(!isNum(p.hz) || p.hz < 0) continue;
      const amp = isNum(p.amp) ? Math.max(0, p.amp) : 0;
      out.push({ hz:p.hz, amp, col:p.col || "#fff", label:p.label || "" });
    }
    return out;
  }

  /* ===================== DESSIN SPECTRE ===================== */
  function drawSpectrum(hzMotor, hzBelt, time){
    const dpr = dprNow();
    const W = specCanvas.width / dpr;
    const H = specCanvas.height / dpr;

    const hzZoneHeight = 42;
    let hzZoneY = spectrumFS ? (H - hzZoneHeight - 80) : (H - hzZoneHeight - 10);
    hzZoneY = Math.max(80, hzZoneY);

    const gridTop    = 16;
    const gridBottom = hzZoneY - 10;
    const gridHeight = gridBottom - gridTop;

    const ampLabelWidth = 58;
    const plotLeft  = ampLabelWidth;
    const plotRight = W;
    const plotWidth = plotRight - plotLeft;

    // ===== AUTO-SCALE AMPLITUDE (OPTION 1) =====
const peaks = buildPeaks(hzMotor, hzBelt, time, faultEl.value);
// ===== ENREGISTREMENT AUTO (uniquement quand Play) =====
if(running){
  for(const p of peaks){
    if(!Number.isFinite(p.hz)) continue;

    // EXACTEMENT le m√™me facteur que l‚Äôaffichage
    const ampMMs = (Number.isFinite(p.amp) ? p.amp : 0) * 5;

    // cl√© = label (donc "1√ó moteur", "Balourd (1√ó)", etc.)
    const key = (p.label || "").trim();
    if(!key) continue;

    // garde le max
    if(!peakRecord[key] || ampMMs > peakRecord[key].amp){
      peakRecord[key] = { hz: p.hz, amp: ampMMs };
    }
  }
}
// amplitude max r√©elle (en mm/s p√©dagogiques)
let maxAmp = 1;
for(const p of peaks){
  const ampMMs = p.amp * 5;   // m√™me facteur que tes barres
  if(ampMMs > maxAmp) maxAmp = ampMMs;
}

// marge p√©dagogique + arrondi propre
const AMP_MAX  = Math.max(2, Math.ceil(maxAmp * 1.15));
const AMP_STEP = AMP_MAX <= 6 ? 1 : 2;
    const minHz = spectrumView.minHz;
    const maxHz = minHz + spectrumView.spanHz;
    const scaleX = plotWidth / (maxHz - minHz);

    specCtx.clearRect(0,0,W,H);
    specCtx.fillStyle = "#05080f";
    specCtx.fillRect(0,0,W,H);

    // bande Hz
    specCtx.fillStyle = "rgba(0,162,255,0.15)";
    specCtx.fillRect(0, hzZoneY, W, hzZoneHeight);

// ===== BANDES ISO (derri√®re les barres) =====
// mapping mm/s -> Y
const yFromAmp = (amp) => gridBottom - (amp / AMP_MAX) * gridHeight;

// on dessine A, B, C, D en bandes horizontales
let prev = 0;
for(const z of ISO_ZONES){
  const topAmp = Math.min(z.max, AMP_MAX);
  const yTop = yFromAmp(topAmp);
  const yBot = yFromAmp(prev);

  // si la bande d√©passe l'√©chelle actuelle, on coupe
  const y1 = Math.max(gridTop, Math.min(gridBottom, yTop));
  const y2 = Math.max(gridTop, Math.min(gridBottom, yBot));
  const hBand = Math.abs(y2 - y1);

  if(hBand > 0.5){
    specCtx.fillStyle = z.col;
    specCtx.fillRect(plotLeft, Math.min(y1,y2), (plotRight - plotLeft), hBand);

    // petit label de zone √† gauche
    specCtx.fillStyle = "rgba(234,241,255,0.85)";
   
    specCtx.textAlign = "left";
    specCtx.textBaseline = "middle";
    specCtx.fillText(`ISO ${ISO_CLASS} ${z.name} (${z.label})`, plotLeft + 6, Math.min(y1,y2) + 12);
  }

  prev = z.max;
}


    // r√®gle Hz
    specCtx.strokeStyle = "rgba(255,255,255,0.35)";
    specCtx.fillStyle   = "#eaf1ff";
    specCtx.font        = "11px Arial";
    specCtx.textAlign   = "center";
    specCtx.textBaseline= "top";

    const majorStep = 10;
    const minorStep = 5;

    for(let hz = Math.ceil(minHz / minorStep) * minorStep; hz <= maxHz; hz += minorStep){
      const x = plotLeft + (hz - minHz) * scaleX;
      const isMajor = (hz % majorStep === 0);

      specCtx.beginPath();
      specCtx.moveTo(x, hzZoneY);
      specCtx.lineTo(x, hzZoneY + (isMajor ? 12 : 6));
      specCtx.stroke();

      if(isMajor){
        specCtx.fillText(hz + " Hz", x, hzZoneY + 14);
      }
    }

    // grille verticale
    specCtx.strokeStyle = "rgba(255,255,255,0.08)";
    for(let i=0;i<=8;i++){
      const x = plotLeft + i * plotWidth / 8;
      specCtx.beginPath();
      specCtx.moveTo(x, gridTop);
      specCtx.lineTo(x, gridBottom);
      specCtx.stroke();
    }

    // grille horizontale + labels mm/s
    specCtx.strokeStyle = "rgba(255,255,255,0.12)";
    specCtx.fillStyle   = "#cfd6ff";
    specCtx.font        = "11px Arial";
    specCtx.textAlign   = "right";
    specCtx.textBaseline= "middle";

    for(let a=0; a<=AMP_MAX; a+=AMP_STEP){
      const y = gridBottom - (a / AMP_MAX) * gridHeight;
      specCtx.beginPath();
      specCtx.moveTo(plotLeft, y);
      specCtx.lineTo(plotRight, y);
      specCtx.stroke();
      specCtx.fillText(a + " mm/s", plotLeft - 6, y);
    }

    const fault = faultEl.value || "none";
    

    // barres
    for(const p of peaks){
      if(!isNum(p.hz) || p.hz < minHz || p.hz > maxHz) continue;

      const x = plotLeft + (p.hz - minHz) * scaleX;

      const ampMMs = p.amp * 5; // facteur p√©dagogique
      const h = (ampMMs / AMP_MAX) * gridHeight;
      const yTop = gridBottom - h;

      specCtx.strokeStyle = p.col;
      specCtx.lineWidth = 3;
      specCtx.beginPath();
      specCtx.moveTo(x, gridBottom);
      specCtx.lineTo(x, yTop);
      specCtx.stroke();

      specCtx.fillStyle = "#cfd6ff";
      specCtx.font = "12px Arial";
      specCtx.textAlign = "center";
      specCtx.textBaseline = "bottom";
      specCtx.fillText(p.label, x, Math.max(yTop - 6, gridTop + 14));
    }
// ===== VERDICT ISO bas√© sur le pic max (dans la fen√™tre affich√©e) =====
let maxShown = 0;
for(const p of peaks){
  if(!Number.isFinite(p.hz)) continue;
  if(p.hz < minHz || p.hz > maxHz) continue;  // seulement ce qui est visible
  const ampMMs = (Number.isFinite(p.amp) ? p.amp : 0) * 5;
  if(ampMMs > maxShown) maxShown = ampMMs;
}

const z = isoVerdict(maxShown);

// bande de titre (en haut √† gauche)
specCtx.fillStyle = "rgba(0,0,0,0.35)";
specCtx.fillRect(plotLeft, 0, 270, 18);

specCtx.fillStyle = "#eaf1ff";
let fontSize = FONT_BASE;

if(isMobile()) fontSize = FONT_MOB;
if(spectrumFS) fontSize = FONT_FS;

spectrumFont(fontSize);
    
specCtx.font = "12px Arial";
specCtx.textAlign = "left";
specCtx.textBaseline = "middle";
specCtx.fillText(`ISO ${ISO_CLASS} : ${z.name} ‚Äî ${z.label} (max ${maxShown.toFixed(2)} mm/s)`, plotLeft + 6, 9);
    // axe
    specCtx.fillStyle = "#9aa5d6";
    specCtx.font = "12px Arial";
    specCtx.textAlign = "right";
    specCtx.textBaseline = "top";
    specCtx.fillText("Hz ‚Üí", W - 6, 6);
  }

function renderPeakList(){
  const keys = Object.keys(peakRecord);

  if(keys.length === 0){
    infoEl.innerHTML = "<div class='small'>üì∏ Aucun pic enregistr√© (appuie Play).</div>";
    return;
  }

  // tri par amplitude d√©croissante
  keys.sort((a,b) => peakRecord[b].amp - peakRecord[a].amp);

  let html = "<b>üì∏ Photo instantan√©e ‚Äî pics max enregistr√©s</b><br><br>";
// verdict global ISO bas√© sur le plus gros pic enregistr√©
let maxRec = 0;
for(const k of keys){
  if(peakRecord[k].amp > maxRec) maxRec = peakRecord[k].amp;
}
const z = isoVerdict(maxRec);
html += `<div style="margin-bottom:12px;"><b>ISO ${ISO_CLASS}</b> : ${z.name} ‚Äî ${z.label} (max ${maxRec.toFixed(2)} mm/s)</div>`;
  for(const label of keys){
    const p = peakRecord[label];
    html += `
      <div style="margin-bottom:10px;">
        ‚Ä¢ <b>${label}</b><br>
        &nbsp;&nbsp;${p.hz.toFixed(2)} Hz ‚Äî ${p.amp.toFixed(2)} mm/s
      </div>
    `;
  }

  infoEl.innerHTML = html;
}



function updateSpectrumModeByOrientation(){
  if(!spectrumFS) return;
  if(!isMobile()) return;

  const isLandscape = window.innerWidth > window.innerHeight;

  if(isLandscape){
    // ‚úÖ paysage : on enl√®ve l'avertissement
    rotateWarn.style.display = "none";

    // ‚úÖ on affiche le HUD pour donner acc√®s au bouton Quitter
    showFSHUD();

    setTimeout(() => {
      resize();
      redrawSpectrumNow();
    }, 150);

  }else{
    // ‚ùå portrait : on bloque le spectre
    rotateWarn.style.display = "flex";
  }
}

  /* ===================== RESIZE ===================== */
  function resize(){
    const dpr = dprNow();

    // largeur verrouill√©e, MAIS si l'√©cran devient plus petit: on re-r√©duit
    const maxW = Math.min(window.innerWidth - 24, 720);
    if(!lockedWidth) lockedWidth = maxW;
    lockedWidth = Math.min(lockedWidth, maxW);

    const w = lockedWidth;
    const h = w * 0.55;

    // sc√®ne
    canvas.style.width  = w + "px";
    canvas.style.height = h + "px";
    canvas.width  = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // spectre
    let specW, specH;
    if(spectrumFS){
      const vv = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
      specW = vv.width;
      specH = vv.height;

      specCanvas.style.position = "fixed";
      specCanvas.style.left = "0";
      specCanvas.style.top  = "0";
      specCanvas.style.margin = "0";
      specCanvas.style.borderRadius = "0";
    }else{
      specW = w;
      specH = Math.max(220, h * 0.95);

      specCanvas.style.position = "relative";
      specCanvas.style.marginTop = "18px";
      specCanvas.style.borderRadius = "12px";
    }

    specCanvas.style.width  = specW + "px";
    specCanvas.style.height = specH + "px";
    specCanvas.width  = Math.round(specW * dpr);
    specCanvas.height = Math.round(specH * dpr);

    specCtx.setTransform(dpr,0,0,dpr,0,0);
    specCtx.imageSmoothingEnabled = false;
  }

  /* ===================== FULLSCREEN / ORIENTATION ===================== */
  
  

  /* ===================== REDRAW SPECTRE (pause ok) ===================== */
  function redrawSpectrumNow(){
    const inp = readInputs();
    if(!inp){
      drawSpectrum(0, 0, tSpec);
      return;
    }

    const geo = validateGeometryOpenBelt(inp);
    const hzMotor = inp.rpm/60;

    if(!geo.ok){
      drawSpectrum(hzMotor, 0, tSpec);
      return;
    }

    const Lmm  = beltLengthOpenBeltMM(inp.d1mm, inp.d2mm, inp.ccmm);
    const vmm  = beltLinearSpeed_mm_s(inp.d1mm, inp.rpm);
    const hzBelt = (Lmm > 0) ? (vmm / Lmm) : 0;

    drawSpectrum(hzMotor, hzBelt, tSpec);
  }

  /* ===================== DRAW GLOBAL ===================== */
  function draw(){
    const dpr = dprNow();
    const W = canvas.width / dpr;
    const H = canvas.height / dpr;

    // fond sc√®ne
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    const inp = readInputs();
    if(!inp){
      infoEl.innerHTML = `<span class="bad">‚õî Entre RPM, √ò menante, √ò men√©e et C-C.</span>`;
      outLength.textContent = "‚Äî";
      outRPM1.textContent = outCPM1.textContent = outHZ1.textContent = "‚Äî";
      outRPM2.textContent = outCPM2.textContent = outHZ2.textContent = "‚Äî";
      outHZBelt.textContent = outFPM.textContent = outStrobe.textContent = "‚Äî";
      drawSpectrum(0,0,tSpec);
      return;
    }

    const geo = validateGeometryOpenBelt(inp);
    if(!geo.ok){
      infoEl.innerHTML = geo.html;

      // stop play (√©vite ‚Äúangles qui partent en NaN‚Äù dans certaines configs)
      running = false;

      const hzMotor = inp.rpm/60;

      outRPM1.textContent = inp.rpm.toFixed(0);
      outCPM1.textContent = inp.rpm.toFixed(0);
      outHZ1.textContent  = hzMotor.toFixed(2);

      const rpmMenee = inp.rpm * (inp.d1mm / inp.d2mm);
      const hzMenee  = rpmMenee/60;
      outRPM2.textContent = rpmMenee.toFixed(0);
      outCPM2.textContent = rpmMenee.toFixed(0);
      outHZ2.textContent  = hzMenee.toFixed(2);

      outHZBelt.textContent = "‚Äî";
      outFPM.textContent    = "‚Äî";
      outStrobe.textContent = "‚Äî";
      outLength.textContent = "‚Äî";

      drawSpectrum(hzMotor, 0, tSpec);
      return;
    }else{
      if(!snapshotMode){
  infoEl.innerHTML = "";
}
    }

    // calculs
    const Lmm = beltLengthOpenBeltMM(inp.d1mm, inp.d2mm, inp.ccmm);
    const v_mm_s   = beltLinearSpeed_mm_s(inp.d1mm, inp.rpm);
    const v_in_s   = v_mm_s / IN_TO_MM;
    const v_ft_min = v_in_s * 5;

    const hzMotor = inp.rpm / 60;
    const hzBelt  = (Lmm > 0) ? (v_mm_s / Lmm) : 0;

    const strobeFPM = hzBelt * 60;

    // outputs
    outLength.textContent = (unitEl.value === "imperial")
      ? (Lmm / IN_TO_MM).toFixed(2) + " po"
      : Lmm.toFixed(1) + " mm";

    outRPM1.textContent = inp.rpm.toFixed(0);
    outCPM1.textContent = inp.rpm.toFixed(0);
    outHZ1.textContent  = hzMotor.toFixed(2);

    const rpmMenee = inp.rpm * (inp.d1mm / inp.d2mm);
    const hzMenee  = rpmMenee / 60;
    outRPM2.textContent = rpmMenee.toFixed(0);
    outCPM2.textContent = rpmMenee.toFixed(0);
    outHZ2.textContent  = hzMenee.toFixed(2);

    outHZBelt.textContent = hzBelt.toFixed(3);
    outFPM.textContent    = v_ft_min.toFixed(0);
    outStrobe.textContent = strobeFPM.toFixed(0);

    // spectre (live uniquement si running car tSpec n‚Äôavance que si running)
    drawSpectrum(hzMotor, hzBelt, tSpec);

    // dessin sc√®ne courroie + poulies
    const r1mm = inp.d1mm/2;
    const r2mm = inp.d2mm/2;
    const Cmm  = inp.ccmm;

    const margin = 26;
    const s = Math.min(
      (W - 2*margin) / (Cmm + r1mm + r2mm),
      (H - 2*margin) / (2 * Math.max(r1mm, r2mm))
    );

    const r1 = r1mm*s, r2 = r2mm*s, C = Cmm*s;
    const x1 = margin + r1;
    const x2 = x1 + C;
    const y  = H/2;

    const pts = buildBeltPath(x1,y,r1, x2,y,r2);

    ctx.strokeStyle = "#9a9a9a";
    ctx.lineWidth = 4;
    ctx.lineCap="round";
    ctx.lineJoin="round";
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();

    drawPulley(x1, y, r1, "#00a2ff", ang1);
    drawPulley(x2, y, r2, "#ff9800", ang2);

    // point sur courroie
    const w1 = TAU*(inp.rpm/60);
    const v_px_s = Math.abs(w1) * r1;
    const totalLen = polylineLength(pts);
    const sPos = (totalLen - (v_px_s * tMotion) % totalLen) % totalLen;
    const P = pointAt(pts, sPos);

    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.arc(P.x,P.y,4,0,TAU);
    ctx.fill();
  }

  /* ===================== LOOP UNIQUE RAF ===================== */
  let lastTS = null;
  function loop(ts){
    if(lastTS === null) lastTS = ts;
    const dt = (ts - lastTS) / 1000;
    lastTS = ts;

    if(running){
      const slow = Math.max(1, parseFloat(slowEl.value) || 1);

      // avance temps (Play seulement)
      tMotion += dt / slow;
      tSpec   += dt;

      // angles: utilisent les valeurs converties (mm) pour ratio correct m√™me en imp√©rial
      const inp = readInputs();
      if(inp){
        const w1 = TAU * (inp.rpm / 60);
        const ratio = inp.d1mm / inp.d2mm;
        const w2 = w1 * ratio;
        ang1 += (w1 * dt) / slow;
        ang2 += (w2 * dt) / slow;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  /* ===================== EVENTS UI ===================== */

window.addEventListener("resize", () => {
  updateSpectrumModeByOrientation();
  draw();
});

window.addEventListener("orientationchange", () => {
  updateSpectrumModeByOrientation();
  draw();
});

if(window.visualViewport){
  window.visualViewport.addEventListener("resize", () => {
    updateSpectrumModeByOrientation();
    draw();
  });
}

playBtn.addEventListener("click", () => {

  snapshotMode = false;   // on quitte le mode photo
  peakRecord = {};        // on repart un nouvel enregistrement
  infoEl.innerHTML = "";  // nettoie l‚Äôaffichage

  const inp = readInputs();
  if(!inp){ running = false; draw(); return; }

  const geo = validateGeometryOpenBelt(inp);
  if(!geo.ok){ running = false; draw(); return; }

  running = true;         // üî¥ LIVE reprend
});
  pauseBtn.addEventListener("click", () => {
  running = false;
  snapshotMode = true;   // üîí verrou affichage
  renderPeakList();      // üì∏ affiche la fiche
});

  resetBtn.addEventListener("click", () => {
  running = false;
  tMotion = 0;
  tSpec   = 0;
  ang1 = 0;
  ang2 = 0;

  peakRecord = {};      // ‚úÖ efface la m√©moire
  infoEl.innerHTML = ""; // optionnel: efface l'affichage

  draw();
});
  
  

  // Inputs : redraw (spectre fig√© si pause)
  [rpmEl,d1El,d2El,ccEl,unitEl,slowEl,faultEl].forEach(el=>{
    el.addEventListener("input", () => {
      // si la g√©om√©trie devient invalide en Play, draw() stoppera running
      draw();
    });
  });

  // Resize / orientation
  function handleViewportChange(){
    resize();
    
    
    draw();
  }
  
  /* ===================== PAN SPECTRE (pause ok) ===================== */
  specCanvas.addEventListener("pointerdown", e => {
    isPanning = true;
    panStartX = e.clientX;
    panStartMin = spectrumView.minHz;
    try{ specCanvas.setPointerCapture(e.pointerId); }catch(_){}
  });

  specCanvas.addEventListener("pointermove", e => {
    if(!isPanning) return;

    const dxPx = e.clientX - panStartX;
    const widthPx = specCanvas.clientWidth || 1;
    const hzPerPx = spectrumView.spanHz / widthPx;

    let newMin = panStartMin - dxPx * hzPerPx;
    newMin = Math.max(0, Math.min(spectrumView.maxHz - spectrumView.spanHz, newMin));
    spectrumView.minHz = newMin;

    // redraw imm√©diat (tSpec fig√© si pause)
    redrawSpectrumNow();
  });

  function endPan(e){
    isPanning = false;
    if(e && e.pointerId != null){
      try{ specCanvas.releasePointerCapture(e.pointerId); }catch(_){}
    }
  }
  specCanvas.addEventListener("pointerup", endPan);
  specCanvas.addEventListener("pointercancel", endPan);

  /* ===================== INIT ===================== */
  resize();
updateSpectrumModeByOrientation();
draw();


function iso10816Class(mm_s){
  if(mm_s < 1.8) return { label:"BON", color:[0,150,0] };
  if(mm_s < 4.5) return { label:"ACCEPTABLE", color:[255,165,0] };
  if(mm_s < 7.1) return { label:"MAUVAIS", color:[255,100,0] };
  return { label:"CRITIQUE", color:[200,0,0] };
}


function exportPDF(){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  const keys = Object.keys(peakRecord);
  if(keys.length === 0){
    alert("Aucune donn√©e enregistr√©e.\n\nAppuie sur Play puis Pause.");
    return;
  }

  let y = 14;

  doc.setFont("helvetica","bold");
  doc.setFontSize(16);
  doc.text("Analyse vibratoire ‚Äî Photo instantan√©e", 14, y);
  y += 10;

  doc.setFontSize(11);
  doc.setFont("helvetica","normal");
  doc.text(`Date : ${new Date().toLocaleString()}`, 14, y);
  y += 10;

  doc.setFont("helvetica","bold");
  doc.text("R√©sultats mesur√©s :", 14, y);
  y += 8;

  const sorted = keys.sort((a,b)=>peakRecord[b].amp - peakRecord[a].amp);

  for(const label of sorted){
    const p = peakRecord[label];
    const iso = iso10816Class(p.amp);

    if(y > 270){
      doc.addPage();
      y = 14;
    }

    doc.setFont("helvetica","bold");
    doc.text(label, 14, y);

    doc.setFont("helvetica","normal");
    y += 6;
    doc.text(`Fr√©quence : ${p.hz.toFixed(2)} Hz`, 18, y);
    y += 6;
    doc.text(`Amplitude : ${p.amp.toFixed(2)} mm/s`, 18, y);
    y += 6;

    doc.setTextColor(...iso.color);
    doc.text(`Classe ISO : ${iso.label}`, 18, y);
    doc.setTextColor(0,0,0);

    y += 10;
  }

  doc.save("Analyse_vibratoire_ISO.pdf");
}
document.addEventListener("keydown", (e) => {
  if(e.key === "Escape" && spectrumFS){
    btnExitFS.click();
  }
});

if(window.visualViewport){
  window.visualViewport.addEventListener("resize", () => {
    updateSpectrumModeByOrientation();
  });
}

enableLongPressFS();
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
